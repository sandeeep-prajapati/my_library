### **1️⃣ MCU Peripherals & Architecture Overview**  
1. **01_introduction_to_mcu_peripherals.md** – What are microcontroller peripherals and their role?  
2. **02_understanding_mcu_architecture_and_memory_map.md** – How is MCU memory structured, and why does it matter?  
3. **03_mcu_bus_interfaces_ahb_apb_explained.md** – How do AHB and APB bus protocols affect peripheral communication?  
4. **04_clock_sources_and_mcu_clock_configuration.md** – How to configure HCLK, PCLK, and PLL for optimal performance?  
5. **05_peripheral_registers_and_control_flow.md** – How do configuration, control, and status registers work?  

---

### **2️⃣ GPIO (General Purpose Input/Output) Driver Development**  
6. **06_gpio_fundamentals_and_configurations.md** – What are GPIO modes, pull-up/down resistors, and speed settings?  
7. **07_writing_a_gpio_driver_from_scratch.md** – How to write a GPIO peripheral driver step by step?  
8. **08_gpio_interrupt_handling_and_nvic.md** – How to configure GPIO interrupts and use the NVIC properly?  
9. **09_gpio_driver_api_design_best_practices.md** – How to design reusable GPIO driver functions?  

---

### **3️⃣ Serial Communication Protocols (SPI, I2C, USART)**  
10. **10_introduction_to_spi_i2c_usart.md** – Overview of SPI, I2C, and USART communication.  
11. **11_spi_protocol_working_and_configuration.md** – How does SPI work, and how to configure it?  
12. **12_developing_a_spi_driver_from_scratch.md** – Step-by-step guide to writing an SPI driver.  
13. **13_i2c_protocol_working_and_configuration.md** – How does I2C work, and how to handle clock stretching?  
14. **14_developing_an_i2c_driver_from_scratch.md** – Writing an I2C driver with register-level programming.  
15. **15_usart_serial_communication_basics.md** – What are baud rates, stop bits, and parity bits in USART?  
16. **16_developing_a_usart_driver_from_scratch.md** – Implementing a USART driver with polling, interrupt, and DMA.  

---

### **4️⃣ Interrupts & NVIC (Nested Vector Interrupt Controller)**  
17. **17_understanding_interrupt_vectors_and_nvic.md** – What is the Vector Table, and how does NVIC manage interrupts?  
18. **18_handling_external_and_peripheral_interrupts.md** – How to configure, enable, and prioritize interrupts?  
19. **19_interrupt_latency_and_optimizing_isr_execution.md** – Best practices for writing efficient interrupt service routines (ISRs).  

---

### **5️⃣ Advanced MCU Peripherals & Debugging**  
20. **20_hardware_timers_and_pwm_configuration.md** – How to configure hardware timers for precise timing?  
21. **21_dma_direct_memory_access_basics.md** – How does DMA work, and how can it optimize MCU performance?  
22. **22_logic_analyzer_basics_and_protocol_tracing.md** – How to use a logic analyzer to debug SPI, I2C, and UART signals?  
23. **23_quick_debugging_tips_for_peripheral_issues.md** – How to troubleshoot common peripheral communication failures?  

---

### **6️⃣ Final Projects & Case Studies**  
24. **24_interfacing_an_oled_display_using_spi.md** – Hands-on project: OLED display communication with SPI.  
25. **25_building_a_temperature_logger_using_i2c.md** – Hands-on project: I2C communication with a temperature sensor.  
26. **26_uart_based_debug_console_for_mcu.md** – Hands-on project: Implementing a UART debug console.  
27. **27_building_a_real_time_clock_driver.md** – Case study: RTC interfacing and low-power modes.  
28. **28_writing_an_mcu_driver_library_best_practices.md** – Structuring a complete driver development library.  
29. **29_peripheral_performance_optimization_techniques.md** – How to optimize peripheral performance for real-time applications?  
30. **30_final_review_and_resources_for_mcu_development.md** – Summary and additional learning resources.  
