
---

### üéØ Goal:

Make your Laravel package install like magic when added via `composer require`, without needing manual commands like:

```bash
php artisan vendor:publish
php artisan migrate
```

---

## üõ†Ô∏è Step-by-Step Implementation

---

### ‚úÖ 1. Setup: ServiceProvider Entry Point

In your `MyToolsServiceProvider.php`, you'll hook into `boot()` and perform auto-installation logic.

We'll use:

* `publishes()` for standard publishing
* Custom logic for auto-publishing & migrations

---

### ‚úÖ 2. Full `boot()` Method Example

```php
public function boot()
{
    $this->loadRoutesFrom(__DIR__.'/../routes/web.php');
    $this->loadViewsFrom(__DIR__.'/../resources/views', 'mytools');
    $this->loadMigrationsFrom(__DIR__.'/../database/migrations');

    // Allow manual publishing if needed
    $this->publishes([
        __DIR__.'/../config/mytools.php' => config_path('mytools.php'),
    ], 'mytools-config');

    $this->publishes([
        __DIR__.'/../resources/views' => resource_path('views/vendor/mytools'),
    ], 'mytools-views');

    $this->publishes([
        __DIR__.'/../database/migrations' => database_path('migrations'),
    ], 'mytools-migrations');

    // üî• Auto install logic (once)
    $this->autoInstallIfNeeded();
}
```

---

### ‚úÖ 3. Add `autoInstallIfNeeded()` Method

Place this in the same `MyToolsServiceProvider` class:

```php
protected function autoInstallIfNeeded()
{
    // Only in console (composer install, artisan commands)
    if (!app()->runningInConsole()) {
        return;
    }

    // Prevent multiple runs
    if (file_exists(storage_path('app/mytools_installed.lock'))) {
        return;
    }

    // Auto publish config
    $this->publishes([
        __DIR__.'/../config/mytools.php' => config_path('mytools.php'),
    ], 'mytools-config');

    // Copy manually without artisan if needed
    $this->copyFile(__DIR__.'/../config/mytools.php', config_path('mytools.php'));
    $this->copyDirectory(__DIR__.'/../resources/views', resource_path('views/vendor/mytools'));
    $this->copyDirectory(__DIR__.'/../database/migrations', database_path('migrations'));

    // Auto-run migrations (optional - advanced)
    try {
        \Artisan::call('migrate', ['--force' => true]);
    } catch (\Exception $e) {
        \Log::error('MyTools auto-migration failed: ' . $e->getMessage());
    }

    // Create lock file to prevent re-running
    file_put_contents(storage_path('app/mytools_installed.lock'), now());
}
```

---

### ‚úÖ 4. Helper Methods (For Copying)

Add these in the same class or a trait:

```php
protected function copyFile($from, $to)
{
    if (!file_exists($to)) {
        @copy($from, $to);
    }
}

protected function copyDirectory($from, $to)
{
    if (!is_dir($from)) return;

    if (!file_exists($to)) {
        mkdir($to, 0755, true);
    }

    foreach (scandir($from) as $file) {
        if ($file !== '.' && $file !== '..') {
            $src = "$from/$file";
            $dest = "$to/$file";
            is_dir($src) ? $this->copyDirectory($src, $dest) : $this->copyFile($src, $dest);
        }
    }
}
```

---

## ‚úÖ Now What Happens?

After installing your package:

```bash
composer require sandeep/mytools
```

‚û°Ô∏è The package automatically:

* Publishes config to `config/mytools.php`
* Publishes views to `resources/views/vendor/mytools/`
* Publishes migrations to `database/migrations/`
* Runs `php artisan migrate`
* Logs a lock file: `storage/app/mytools_installed.lock`

---

## ‚úÖ Summary

| ‚úÖ Feature           | Implementation                       |
| ------------------- | ------------------------------------ |
| Auto config publish | `copyFile()` or `publishes()`        |
| Auto view publish   | `copyDirectory()`                    |
| Auto migration run  | `Artisan::call('migrate')`           |
| One-time lock       | `storage/app/mytools_installed.lock` |

---

### üß† Pro Tip:

If your package gets more complex, consider:

* Showing a console "wizard" using `Command::ask()`
* Creating a custom `php artisan mytools:install` command (as a fallback)

---
