Here's a comprehensive strategy to manage multiple model versions in your vector search system, with implementation examples for both Qdrant and application logic:

---

### **1. Versioned Collections Approach**
**Best for**: Complete model version isolation

#### **Qdrant Collection Naming**
```python
# When creating collections
client.create_collection(
    collection_name="products_v1",  # Model version 1
    vectors_config=VectorParams(size=512, distance=Distance.COSINE)
)

client.create_collection(
    collection_name="products_v2",  # Model version 2
    vectors_config=VectorParams(size=768, distance=Distance.COSINE)  # Different embedding size
)
```

#### **Laravel Configuration**
```php
// config/services.php
return [
    'qdrant' => [
        'current_version' => env('QDRANT_MODEL_VERSION', 'v2'),
        'collections' => [
            'v1' => 'products_v1',
            'v2' => 'products_v2'
        ]
    ]
];
```

#### **Search with Version Switching**
```php
public function search(Request $request)
{
    $version = $request->input('version', config('services.qdrant.current_version'));
    $collection = config("services.qdrant.collections.$version");

    $results = Http::post("qdrant-url/collections/{$collection}/points/search", [
        'vector' => $embedding,
        'limit' => 5
    ]);
}
```

---

### **2. Payload Metadata Approach** 
**Best for**: A/B testing with same collection

#### **Vector Insertion with Version**
```python
# When adding vectors
client.upsert(
    collection_name="products",
    points=[
        PointStruct(
            id=1,
            vector=[...],
            payload={
                "model_version": "v2",
                "product_id": "123",
                # ... other metadata
            }
        )
    ]
)
```

#### **Versioned Searching**
```python
# Search only v2 results
search_result = client.search(
    collection_name="products",
    query_vector=[...],
    query_filter=Filter(
        must=[
            FieldCondition(
                key="model_version",
                match=MatchValue(value="v2")
            )
        ]
    )
)
```

---

### **3. Hybrid Approach (Recommended)**
Combine both strategies for maximum flexibility:

```mermaid
graph TD
    A[Model v1] --> B[Collection: products_v1]
    A --> C[Metadata: {model: "resnet50", version: "v1"}]
    D[Model v2] --> E[Collection: products_v2] 
    D --> F[Metadata: {model: "clip", version: "v2"}]
```

---

### **4. Migration System**
#### **Version Migration Job**
```php
// app/Jobs/MigrateVectorsToV2.php
public function handle()
{
    $v1Vectors = $this->getV1Vectors();
    
    $v2Vectors = $v1Vectors->map(function ($item) {
        return [
            'id' => $item->id,
            'vector' => $this->generateV2Embedding($item),
            'payload' => array_merge($item->payload, [
                'model_version' => 'v2',
                'original_version' => 'v1'
            ])
        ];
    });

    Http::put('qdrant-url/collections/products_v2/points', [
        'points' => $v2Vectors
    ]);
}
```

#### **Blue-Green Deployment**
1. Keep both collections active during transition
2. Route percentage of traffic to new version
3. Compare metrics before full switch

---

### **5. Query Routing Layer**
```python
# API endpoint
@app.post("/search")
async def search(request: Request):
    version = get_request_version(request)
    
    if version == "v1":
        collection = "products_v1"
        embedding = generate_v1_embedding(request.text)
    else:
        collection = "products_v2"
        embedding = generate_v2_embedding(request.text)
    
    results = search_qdrant(collection, embedding)
    
    return {
        "results": results,
        "model_version": version,
        "collection_used": collection
    }
```

---

### **6. Version Cleanup System**
Automatically archive old versions:

```python
# Archive collections older than 3 versions
def cleanup_old_versions():
    collections = client.get_collections()
    versions = sorted([c.name for c in collections if c.name.startswith("products_v")])
    
    for old_version in versions[:-3]:
        client.delete_collection(old_version)
        log(f"Archived {old_version}")
```

---

### **7. Monitoring Dashboard**
Track key metrics per version:

| Metric          | v1    | v2    | Delta  |
|-----------------|-------|-------|--------|
| Precision@5     | 0.72  | 0.81  | +12.5% |
| Latency (ms)    | 45    | 52    | +15.5% |
| Cache Hit Rate  | 88%   | 92%   | +4%    |

---

### **Implementation Checklist**

1. **Storage Strategy**:
   - [ ] Versioned collection names OR
   - [ ] Version metadata in payload

2. **Indexing**:
   - [ ] Create payload index for `model_version`
   - [ ] Different distance metrics per version if needed

3. **Query Routing**:
   - [ ] Header/param for version selection
   - [ ] Default to current stable version

4. **Migration**:
   - [ ] Batch migration jobs
   - [ ] Verification checks

5. **Monitoring**:
   - [ ] Metrics collection per version
   - [ ] Automated alerts on regression

6. **Cleanup**:
   - [ ] Archive policy for old versions
   - [ ] Backup before deletion

---

### **Recommended Approach**
For most production systems, use **versioned collections** because:
1. Complete isolation prevents version interference
2. Different vector dimensions/similarity metrics per version
3. Easier rollback and performance comparison
4. Clear storage separation

Reserve payload metadata for:
- Experimental features within same model version
- A/B testing with small traffic percentages
- Temporary model variants

This architecture gives you robust version control while maintaining search performance and operational flexibility.