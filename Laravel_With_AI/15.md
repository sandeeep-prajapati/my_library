Here's a complete implementation to handle user queries in Laravel, vectorize them via Python, and return similar items from Qdrant:

---

### **1. Laravel Controller (`app/Http/Controllers/SearchController.php`)**
```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use App\Models\Product;

class SearchController extends Controller
{
    public function semanticSearch(Request $request)
    {
        $request->validate([
            'query' => 'required|string|max:255',
            'limit' => 'sometimes|integer|min:1|max:50',
            'filters' => 'sometimes|array'
        ]);

        try {
            // Step 1: Convert query to vector
            $vectorResponse = Http::timeout(30)
                ->retry(3, 500)
                ->post(config('services.ml.embedding_url'), [
                    'text' => $request->query
                ]);

            if (!$vectorResponse->successful()) {
                throw new \Exception("Embedding service error: ".$vectorResponse->body());
            }

            $vector = $vectorResponse->json()['embedding'];

            // Step 2: Search Qdrant with vector + filters
            $searchResponse = Http::withHeaders(['Content-Type' => 'application/json'])
                ->post(config('services.qdrant.url').'/collections/products/points/search', [
                    'vector' => $vector,
                    'limit' => $request->input('limit', 10),
                    'with_payload' => true,
                    'filter' => $this->buildFilters($request->filters)
                ]);

            if (!$searchResponse->successful()) {
                throw new \Exception("Vector search error: ".$searchResponse->body());
            }

            // Step 3: Format results with product data
            $results = collect($searchResponse->json()['result'])
                ->map(function ($item) {
                    $product = Product::where('sku', $item['payload']['product_id'])->first();
                    return [
                        'product' => $product,
                        'score' => round($item['score'], 3),
                        'payload' => $item['payload']
                    ];
                });

            return response()->json([
                'success' => true,
                'results' => $results,
                'query_vector' => $vector // Optional for debugging
            ]);

        } catch (\Exception $e) {
            Log::error("Search failed: ".$e->getMessage());
            return response()->json([
                'success' => false,
                'message' => 'Search service unavailable'
            ], 503);
        }
    }

    protected function buildFilters(?array $filters): ?array
    {
        if (empty($filters)) return null;

        $qdrantFilters = ['must' => []];

        foreach ($filters as $key => $value) {
            if ($key === 'price_range') {
                $qdrantFilters['must'][] = [
                    'key' => 'price',
                    'range' => [
                        'gte' => $value['min'],
                        'lte' => $value['max']
                    ]
                ];
            } else {
                $qdrantFilters['must'][] = [
                    'key' => $key,
                    'match' => ['value' => $value]
                ];
            }
        }

        return $qdrantFilters;
    }
}
```

---

### **2. Python FastAPI Embedding Endpoint (`fastapi/main.py`)**
```python
from fastapi import FastAPI
from pydantic import BaseModel
import numpy as np
from sentence_transformers import SentenceTransformer

app = FastAPI()

# Load model on startup
model = None

@app.on_event("startup")
async def load_model():
    global model
    model = SentenceTransformer('all-MiniLM-L6-v2')  # 384-dim embeddings

class TextRequest(BaseModel):
    text: str

@app.post("/embed")
async def embed_text(request: TextRequest):
    try:
        embedding = model.encode(request.text).tolist()
        return {"embedding": embedding}
    except Exception as e:
        return {"error": str(e)}, 500
```

---

### **3. Routes (`routes/api.php`)**
```php
Route::post('/search/semantic', [SearchController::class, 'semanticSearch']);
```

---

### **4. JavaScript Frontend Example**
```javascript
// resources/js/components/SemanticSearch.vue
<template>
  <div>
    <input v-model="query" @keyup.enter="search" placeholder="Search products...">
    <button @click="search">Search</button>
    
    <div v-if="results.length">
      <div v-for="item in results" :key="item.product.id" class="product-card">
        <h3>{{ item.product.name }}</h3>
        <p>Score: {{ item.score }}</p>
        <p>${{ item.payload.price }}</p>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      query: '',
      results: []
    }
  },
  methods: {
    async search() {
      try {
        const response = await axios.post('/api/search/semantic', {
          query: this.query,
          filters: {
            category: 'electronics',
            price_range: { min: 50, max: 200 }
          }
        });
        this.results = response.data.results;
      } catch (error) {
        console.error('Search failed:', error);
      }
    }
  }
}
</script>
```

---

### **5. Configuration (`config/services.php`)**
```php
return [
    'qdrant' => [
        'url' => env('QDRANT_URL', 'http://localhost:6333'),
        'collection' => env('QDRANT_COLLECTION', 'products')
    ],
    'ml' => [
        'embedding_url' => env('ML_EMBEDDING_URL', 'http://localhost:8000/embed')
    ]
];
```

---

### **6. Error Handling & Monitoring**

#### **Custom Exception Handler**
```php
// app/Exceptions/Handler.php
public function register()
{
    $this->renderable(function (SearchException $e) {
        return response()->json([
            'success' => false,
            'message' => $e->getMessage()
        ], 503);
    });
}
```

#### **Logging Context**
```php
Log::channel('search')->info('Semantic search performed', [
    'query' => $request->query,
    'result_count' => count($results),
    'response_time' => microtime(true) - $startTime
]);
```

---

### **7. Performance Optimizations**

#### **Caching Embeddings**
```php
$vector = Cache::remember("query_vec:".md5($request->query), 3600, function() use ($request) {
    return $this->getQueryVector($request->query);
});
```

#### **Async Processing**
```javascript
// Frontend debouncing
let searchTimeout;
watch(() => this.query, () => {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(this.search, 300);
});
```

---

### **Key Features**
1. **End-to-End Pipeline**:
   - Text query → Vector → Similar products
2. **Hybrid Search**:
   - Combines semantic search with filters
3. **Production Ready**:
   - Timeouts, retries, and proper error handling
4. **Scalable**:
   - Decoupled Laravel/Python services
5. **Monitoring**:
   - Detailed logging and cache support

---

### **Testing the Flow**

1. **Send a test query**:
```bash
curl -X POST http://laravel.test/api/search/semantic \
  -H "Content-Type: application/json" \
  -d '{"query": "comfortable wireless headphones", "filters": {"category": "electronics"}}'
```

2. **Expected Response**:
```json
{
  "success": true,
  "results": [
    {
      "product": {
        "id": 123,
        "name": "Noise-Cancelling Bluetooth Headphones",
        "price": 179.99
      },
      "score": 0.872,
      "payload": {
        "category": "electronics",
        "price": 179.99
      }
    }
  ]
}
```

This implementation gives you a **production-grade semantic search** system that can be extended with:
- Multi-modal search (text + image)
- Personalization (user-specific vectors)
- A/B testing different embedding models