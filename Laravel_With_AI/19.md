Here's a comprehensive guide to implementing filtered vector searches in Qdrant using metadata, with examples for both HTTP API and Python client:

---

### **1. Basic Filtered Search (Single Condition)**

#### **Python Client Example**
```python
from qdrant_client import QdrantClient
from qdrant_client.http import models

client = QdrantClient("localhost", port=6333)

search_result = client.search(
    collection_name="products",
    query_vector=[0.1, 0.2, ..., 0.9],  # Your query embedding
    query_filter=models.Filter(
        must=[
            models.FieldCondition(
                key="category",
                match=models.MatchValue(value="shoes")
            )
        ]
    ),
    limit=5
)
```

#### **HTTP API Equivalent**
```bash
curl -X POST http://localhost:6333/collections/products/points/search \
  -H 'Content-Type: application/json' \
  -d '{
    "vector": [0.1, 0.2, ..., 0.9],
    "filter": {
      "must": [
        {"key": "category", "match": {"value": "shoes"}}
      ]
    },
    "limit": 5
  }'
```

---

### **2. Complex Filters (Multiple Conditions)**

#### **Price Range + Category**
```python
search_result = client.search(
    collection_name="products",
    query_vector=[...],
    query_filter=models.Filter(
        must=[
            models.FieldCondition(
                key="category",
                match=models.MatchValue(value="shoes")
            ),
            models.FieldCondition(
                key="price",
                range=models.Range(
                    gte=50.0,
                    lte=100.0
                )
            )
        ]
    )
)
```

#### **HTTP API**
```json
{
  "filter": {
    "must": [
      {"key": "category", "match": {"value": "shoes"}},
      {"key": "price", "range": {"gte": 50.0, "lte": 100.0}}
    ]
  }
}
```

---

### **3. Advanced Filter Types**

#### **A. Text Search (Full-Text)**
```python
models.FieldCondition(
    key="description",
    match=models.MatchText(text="running")  # Full-text search
)
```

#### **B. Multiple Values (OR Condition)**
```python
models.FieldCondition(
    key="category",
    match=models.MatchAny(any=["shoes", "sneakers", "footwear"])
)
```

#### **C. Boolean Filter**
```python
models.FieldCondition(
    key="in_stock",
    match=models.MatchValue(value=True)
)
```

#### **D. Nested Metadata**
```python
models.FieldCondition(
    key="metadata.color",
    match=models.MatchValue(value="red")
)
```

---

### **4. Combining Must/Should/Must Not**

```python
filter = models.Filter(
    must=[  # ALL must match
        models.FieldCondition(key="category", match=models.MatchValue(value="shoes"))
    ],
    should=[  # At least one should match
        models.FieldCondition(key="brand", match=models.MatchValue(value="nike")),
        models.FieldCondition(key="price", range=models.Range(lte=100.0))
    ],
    must_not=[  # None should match
        models.FieldCondition(key="on_sale", match=models.MatchValue(value=False))
    ]
)
```

---

### **5. Laravel Integration Example**

#### **Search Controller**
```php
public function filteredSearch(Request $request)
{
    $validated = $request->validate([
        'query_vector' => 'required|array',
        'category' => 'sometimes|string',
        'min_price' => 'sometimes|numeric',
        'max_price' => 'sometimes|numeric'
    ]);

    $filter = [];
    
    // Build filter dynamically
    if ($request->has('category')) {
        $filter['must'][] = [
            'key' => 'category',
            'match' => ['value' => $request->category]
        ];
    }

    if ($request->has(['min_price', 'max_price'])) {
        $filter['must'][] = [
            'key' => 'price',
            'range' => [
                'gte' => $request->min_price,
                'lte' => $request->max_price
            ]
        ];
    }

    $response = Http::post(config('services.qdrant.url').'/collections/products/points/search', [
        'vector' => $validated['query_vector'],
        'filter' => $filter,
        'limit' => 10
    ]);

    return $response->json();
}
```

---

### **6. Performance Optimization**

#### **A. Payload Indexing**
```python
# Create index for faster filtering
client.create_payload_index(
    collection_name="products",
    field_name="category",
    field_type=models.PayloadSchemaType.KEYWORD
)

client.create_payload_index(
    collection_name="products",
    field_name="price",
    field_type=models.PayloadSchemaType.FLOAT
)
```

#### **B. Filter Order Matters**
```python
# More selective filters first
filter = models.Filter(
    must=[
        # 1. Highly selective filter (reduces candidates quickly)
        models.FieldCondition(key="category", match=models.MatchValue(value="shoes")),
        
        # 2. Less selective filter
        models.FieldCondition(key="color", match=models.MatchValue(value="red"))
    ]
)
```

---

### **7. Real-World Example: E-Commerce Search**

```python
def search_products(query_vector, filters):
    """Search with multiple filters"""
    query_filter = models.Filter(
        must=[
            models.FieldCondition(
                key="category",
                match=models.MatchValue(value=filters['category'])
            ),
            models.FieldCondition(
                key="price",
                range=models.Range(
                    gte=filters['min_price'],
                    lte=filters['max_price']
                )
            ),
            models.FieldCondition(
                key="stock_status",
                match=models.MatchValue(value="in_stock")
            )
        ],
        should=[
            models.FieldCondition(
                key="attributes",
                match=models.MatchText(text=filters.get('search_term', ""))
            )
        ],
        must_not=[
            models.FieldCondition(
                key="excluded_for_user",
                match=models.MatchValue(value=True)
            )
        ]
    )
    
    return client.search(
        collection_name="products",
        query_vector=query_vector,
        query_filter=query_filter,
        limit=filters.get('limit', 10)
    )
```

---

### **8. Monitoring Filter Performance**

```python
# Check filter effectiveness
from qdrant_client.http.models import SearchParams

results = client.search(
    collection_name="products",
    query_vector=[...],
    query_filter=...,
    search_params=SearchParams(
        exact=True  # Disable approximation for benchmarking
    )
)
```

---

### **Key Takeaways**

1. **Filter Structure**:
   - `must`: ALL conditions must be true (AND)
   - `should`: AT LEAST ONE condition must be true (OR)
   - `must_not`: NONE should be true (NOT)

2. **Indexing**:
   - Create payload indexes for frequently filtered fields
   - Use `KEYWORD` for exact matches, `TEXT` for full-text

3. **Performance**:
   - Order filters from most to least selective
   - Monitor with `exact=true` for benchmarking

4. **Dynamic Filters**:
   - Build filters programmatically based on user input
   - Validate filter parameters carefully

This implementation allows for sophisticated filtered searches while maintaining high performance in production environments.