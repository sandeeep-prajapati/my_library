Here's a step-by-step guide to deploy the full stack (Qdrant + FastAPI + Laravel) on **Railway.app** or **Render**, with Dockerized services and Railway's PostgreSQL:

---

### **1. Project Structure**
```
your-project/
├── laravel/               # Laravel app
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── (Laravel files...)
├── fastapi/               # Python service
│   ├── Dockerfile
│   ├── requirements.txt
│   └── (FastAPI files...)
└── qdrant/                # Qdrant config (if custom needed)
```

---

### **2. Dockerize FastAPI (`fastapi/Dockerfile`)**
```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["gunicorn", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "main:app", "--bind", "0.0.0.0:8000"]
```

**`requirements.txt`**:
```
fastapi==0.95.2
uvicorn==0.22.0
gunicorn==20.1.0
torch==2.0.1
pillow==10.0.0
numpy==1.24.3
qdrant-client==1.3.2
```

---

### **3. Dockerize Laravel (`laravel/Dockerfile`)**
```dockerfile
FROM php:8.2-fpm

# Install dependencies
RUN apt-get update && apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip \
    && docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Install Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

WORKDIR /var/www

COPY . .

RUN composer install --optimize-autoloader --no-dev \
    && chown -R www-data:www-data storage bootstrap/cache

CMD ["php-fpm"]
```

---

### **4. Docker Compose for Local Dev (`laravel/docker-compose.yml`)**
```yaml
version: '3.8'

services:
  laravel:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - .:/var/www
    environment:
      - DB_HOST=railway-postgres
      - DB_PORT=5432
      - DB_DATABASE=${DB_NAME}
      - DB_USERNAME=${DB_USER}
      - DB_PASSWORD=${DB_PASSWORD}
      - QDRANT_HOST=qdrant
      - ML_SERVICE_URL=http://fastapi:8000
    depends_on:
      - railway-postgres
      - qdrant
      - fastapi

  fastapi:
    build: ../fastapi
    ports:
      - "8001:8000"
    environment:
      - QDRANT_HOST=qdrant

  qdrant:
    image: qdrant/qdrant
    ports:
      - "6333:6333"
    volumes:
      - qdrant_data:/qdrant/storage

  railway-postgres:
    image: postgres:15
    environment:
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=${DB_NAME}
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  qdrant_data:
  postgres_data:
```

---

### **5. Deploy to Railway.app**

#### **A. Create Projects**
1. Create **3 separate Railway projects**:
   - `Laravel App`
   - `FastAPI Service`
   - `Qdrant DB`

#### **B. Deploy Qdrant**
```bash
# In Qdrant project
railway up --service qdrant --detach
railway env set QDRANT__SERVICE__HTTP_PORT=6333
```

#### **C. Deploy FastAPI**
1. Link GitHub repo with `fastapi/` directory
2. Add environment variables:
   ```
   QDRANT_HOST = [Qdrant service URL]
   QDRANT_PORT = 6333
   ```
3. Deploy

#### **D. Deploy Laravel**
1. Link GitHub repo with `laravel/` directory
2. Add PostgreSQL plugin
3. Set environment variables:
   ```ini
   DB_CONNECTION=pgsql
   DB_HOST=[Railway PostgreSQL host]
   DB_PORT=5432
   DB_DATABASE=[Railway PostgreSQL db name]
   DB_USERNAME=[Railway PostgreSQL user]
   DB_PASSWORD=[Railway PostgreSQL password]
   
   QDRANT_HOST=[Qdrant service URL]
   QDRANT_PORT=6333
   
   ML_SERVICE_URL=[FastAPI service URL]
   ```

---

### **6. Deploy to Render (Alternative)**

#### **A. Qdrant Service**
1. Create a **Web Service** with:
   - Docker command: `qdrant/qdrant`
   - Port: `6333`
   - Volume: `/qdrant/storage`

#### **B. FastAPI Service**
1. Create a **Web Service** with:
   - Build command: `docker build -t fastapi .`
   - Start command: `gunicorn -w 4 -k uvicorn.workers.UvicornWorker main:app --bind 0.0.0.0:8000`
   - Environment:
     ```ini
     QDRANT_HOST = [Qdrant service URL]
     QDRANT_PORT = 6333
     ```

#### **C. Laravel App**
1. Create a **Web Service** with:
   - PHP environment
   - PostgreSQL database
   - Environment variables (same as Railway)

---

### **7. Required Laravel Config**

#### **`config/database.php`**
```php
'pgsql' => [
    'driver' => 'pgsql',
    'url' => env('DATABASE_URL'),
    'host' => env('DB_HOST'),
    'port' => env('DB_PORT'),
    'database' => env('DB_DATABASE'),
    'username' => env('DB_USERNAME'),
    'password' => env('DB_PASSWORD'),
    'charset' => 'utf8',
    'prefix' => '',
    'prefix_indexes' => true,
    'schema' => 'public',
    'sslmode' => 'prefer',
],
```

#### **`.env` Example**
```ini
DB_CONNECTION=pgsql
DB_HOST=containers-us-west-123.railway.app
DB_PORT=5432
DB_DATABASE=railway
DB_USERNAME=postgres
DB_PASSWORD=your-password

QDRANT_HOST=your-qdrant-url.up.railway.app
QDRANT_PORT=6333

ML_SERVICE_URL=your-fastapi-url.up.railway.app
```

---

### **8. CI/CD Pipeline (GitHub Actions)**

#### **`.github/workflows/deploy.yml`**
```yaml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      # Deploy Laravel
      - name: Deploy to Railway
        uses: railwayapp/action@v1
        with:
          service: laravel
          environment: production
          token: ${{ secrets.RAILWAY_TOKEN }}
          
      # Deploy FastAPI
      - name: Deploy FastAPI
        uses: railwayapp/action@v1
        with:
          service: fastapi
          token: ${{ secrets.RAILWAY_TOKEN }}
```

---

### **Key Notes**
1. **Networking**:
   - Use Railway's **private networking** for inter-service communication
   - For Render, use **internal service URLs**

2. **Scaling**:
   - Qdrant: Enable **replication** in production
   - FastAPI: Increase **Gunicorn workers** based on CPU cores

3. **Cost Optimization**:
   - Railway: Use **Ephemeral** containers for dev
   - Render: Use **Free Tier** for small projects

4. **Backups**:
   - Configure **automated backups** for PostgreSQL
   - Qdrant snapshots to **S3-compatible storage**

This setup gives you a **production-ready** vector search pipeline with:
- Horizontal scaling
- Managed databases
- Zero-downtime deployments
- Secure inter-service communication