Here's how to **add metadata to vectors in Qdrant** using both the Python client and HTTP API, with examples for product data:

---

### **1. Adding Vectors with Metadata (Python Client)**
```python
from qdrant_client import QdrantClient
from qdrant_client.http import models

client = QdrantClient(host="localhost", port=6333)  # Or your cloud URL

# Insert single point with metadata
client.upsert(
    collection_name="products",
    points=[
        models.PointStruct(
            id=1,  # Unique ID
            vector=[0.1, 0.2, ..., 0.512],  # Your embedding
            payload={
                "product_id": "prod_123",
                "title": "Men's Red T-Shirt",
                "category": "clothing",
                "price": 19.99,
                "tags": ["cotton", "summer"],
                "in_stock": True
            }
        )
    ]
)

# Batch insert with metadata
client.upsert(
    collection_name="products",
    points=[
        models.PointStruct(
            id=2,
            vector=[0.3, 0.5, ..., 0.1],
            payload={
                "product_id": "prod_456",
                "title": "Wireless Headphones",
                "category": "electronics"
            }
        ),
        models.PointStruct(
            id=3,
            vector=[0.8, 0.4, ..., 0.7],
            payload={
                "product_id": "prod_789",
                "title": "Organic Coffee",
                "category": "groceries"
            }
        )
    ]
)
```

---

### **2. Using HTTP API (curl)**
```bash
curl -X POST http://localhost:6333/collections/products/points \
  -H 'Content-Type: application/json' \
  -d '{
    "points": [
      {
        "id": 4,
        "vector": [0.9, 0.1, ..., 0.3],
        "payload": {
          "product_id": "prod_101",
          "title": "Yoga Mat",
          "category": "fitness",
          "attributes": {
            "color": "blue",
            "size": "XL"
          }
        }
      }
    ]
  }'
```

---

### **3. Metadata Best Practices**

#### **Supported Data Types**
```python
payload = {
    "text": "string",        # Good for searchable text
    "number": 123,          # Integer or float
    "bool": True,           # Boolean
    "list": ["a", "b"],     # Array of values
    "dict": {"k": "v"},     # Nested objects
    "null": None            # Null values
}
```

#### **Optimized Schema Setup**
```python
client.create_collection(
    collection_name="products",
    vectors_config=models.VectorParams(size=512, distance=models.Distance.COSINE),
    payload_schema={
        "product_id": models.PayloadSchemaType.KEYWORD,  # Exact match
        "title": models.PayloadSchemaType.TEXT,          # Full-text search
        "category": models.PayloadSchemaType.KEYWORD,
        "price": models.PayloadSchemaType.FLOAT,
        "in_stock": models.PayloadSchemaType.BOOL
    }
)
```

---

### **4. Searching with Metadata Filters**
#### **Python Example**
```python
from qdrant_client.http import models

# Find similar products only in 'electronics' category
hits = client.search(
    collection_name="products",
    query_vector=[0.4, 0.2, ..., 0.9],
    query_filter=models.Filter(
        must=[
            models.FieldCondition(
                key="category",
                match=models.MatchValue(value="electronics")
            ),
            models.FieldCondition(
                key="price",
                range=models.Range(
                    gte=10,
                    lte=100
                )
            )
        ]
    ),
    limit=5
)
```

#### **HTTP API Equivalent**
```bash
curl -X POST http://localhost:6333/collections/products/points/search \
  -H 'Content-Type: application/json' \
  -d '{
    "vector": [0.4, 0.2, ..., 0.9],
    "filter": {
      "must": [
        {"key": "category", "match": {"value": "electronics"}},
        {"key": "price", "range": {"gte": 10, "lte": 100}}
      ]
    },
    "limit": 5
  }'
```

---

### **5. Updating Metadata**
#### **Partial Update (Python)**
```python
client.set_payload(
    collection_name="products",
    payload={
        "sale_price": 15.99,
        "on_sale": True
    },
    points=[2],  # Update specific point IDs
    wait=True    # Wait until changes are applied
)
```

#### **Full Replace (HTTP)**
```bash
curl -X PUT http://localhost:6333/collections/products/points/payload \
  -H 'Content-Type: application/json' \
  -d '{
    "payload": {
      "title": "Updated Product Name",
      "category": "new-category"
    },
    "points": [1, 3]  # IDs to update
  }'
```

---

### **6. Laravel Integration Example**
```php
use Illuminate\Support\Facades\Http;

// Store product with embedding
$response = Http::withHeaders([
    'Content-Type' => 'application/json'
])->post('http://qdrant:6333/collections/products/points', [
    'points' => [
        [
            'id' => $product->id,
            'vector' => $embedding,
            'payload' => [
                'product_id' => $product->sku,
                'title' => $product->name,
                'category' => $product->category->name,
                'price' => $product->price
            ]
        ]
    ]
]);
```

---

### **Key Considerations**
1. **Indexing**: 
   ```python
   # Create payload index for faster filtering
   client.create_payload_index(
       collection_name="products",
       field_name="category",
       field_schema=models.PayloadSchemaType.KEYWORD
   )
   ```

2. **Storage Optimization**:
   - Use `KEYWORD` for enum-like fields (categories, tags)
   - Use `TEXT` for searchable descriptions
   - Avoid storing large JSON blobs

3. **Atomic Updates**:
   - Qdrant guarantees atomicity for single-point operations
   - For batch updates, use `wait=True` to confirm persistence

This implementation gives you **structured metadata** with vectors, enabling hybrid search (vector + metadata filtering) in production applications.