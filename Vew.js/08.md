### Fetching Data from Laravel API in Vue.js with Axios

Here's a complete, production-ready approach to consuming Laravel API endpoints in Vue:

#### 1. First, set up Axios globally (recommended):

```javascript
// resources/js/axios.js
import axios from 'axios';

const api = axios.create({
  baseURL: '/api', // Your Laravel API prefix
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json',
  },
});

// Request interceptor for auth tokens
api.interceptors.request.use(config => {
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor for error handling
api.interceptors.response.use(
  response => response,
  error => {
    if (error.response.status === 401) {
      // Handle unauthorized
      router.push('/login');
    }
    return Promise.reject(error);
  }
);

export default api;
```

#### 2. Create a composable for API calls (modern approach):

```javascript
// resources/js/composables/useApi.js
import { ref } from 'vue';
import api from '@/axios';

export function useApi() {
  const data = ref(null);
  const loading = ref(false);
  const error = ref(null);

  const fetchData = async (url, config = {}) => {
    loading.value = true;
    error.value = null;
    try {
      const response = await api.get(url, config);
      data.value = response.data;
    } catch (err) {
      error.value = err.response?.data?.message || err.message;
    } finally {
      loading.value = false;
    }
  };

  return { data, loading, error, fetchData };
}
```

#### 3. Use in components with reactive state:

```vue
<script setup>
import { useApi } from '@/composables/useApi';

const { data: posts, loading, error, fetchData } = useApi();

// Fetch on component mount
fetchData('/posts');

// Optional: Refetch with filters
const applyFilters = (filters) => {
  fetchData('/posts', { params: filters });
};
</script>

<template>
  <div v-if="loading">Loading...</div>
  <div v-else-if="error" class="text-red-500">{{ error }}</div>
  <ul v-else>
    <li v-for="post in posts" :key="post.id">
      {{ post.title }}
    </li>
  </ul>
</template>
```

#### 4. For POST/PUT/DELETE operations:

```javascript
// In your useApi composable
const postData = async (url, payload) => {
  loading.value = true;
  try {
    const response = await api.post(url, payload);
    data.value = response.data;
    return response;
  } catch (err) {
    error.value = err.response?.data?.errors || err.message;
    throw err; // Re-throw for form handling
  } finally {
    loading.value = false;
  }
};

// In component:
const handleSubmit = async () => {
  try {
    await postData('/posts', formData);
    // Success handling
  } catch {
    // Error displayed via the composable
  }
};
```

#### 5. Laravel API best practices:

1. **API Resource Classes** (for consistent responses):
```php
// app/Http/Resources/PostResource.php
public function toArray($request)
{
  return [
    'id' => $this->id,
    'title' => $this->title,
    'created_at' => $this->created_at->diffForHumans()
  ];
}
```

2. **Pagination**:
```javascript
fetchData('/posts?page=2');
```
```php
// Controller
return PostResource::collection(Post::paginate(15));
```

3. **Error Handling**:
```php
// Handler.php
public function render($request, Throwable $e)
{
  if ($request->expectsJson()) {
    return response()->json([
      'message' => $e->getMessage(),
      'errors' => $e->errors() // For validation
    ], $this->getStatusCode($e));
  }
  // ...
}
```

#### 6. Advanced: TypeScript Support

```typescript
// types/api.d.ts
interface Post {
  id: number;
  title: string;
  body: string;
  created_at: string;
}

// In composable
const fetchData = async <T>(url: string): Promise<T> => {
  const response = await api.get<T>(url);
  return response.data;
};

// Usage
const posts = await fetchData<Post[]>('/posts');
```

#### Key Takeaways:

1. **Centralize API logic** in axios instance + composables
2. **Handle loading/error states** reactively
3. **Use Laravel Resources** for consistent API responses
4. **Implement proper error handling** for production
5. **TypeScript** adds safety for larger apps

This approach gives you:
- Reusable API logic
- Great TypeScript support
- Production-ready error handling
- Seamless Laravel integration
