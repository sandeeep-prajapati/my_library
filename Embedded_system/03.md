Great topic, Sandeep! Here's a full comparison between `malloc` and `new`, followed by a C++ program that:

1. Uses both `malloc` and `new`.
2. Demonstrates how memory leaks can happen.
3. Uses **Valgrind-compatible** style for detecting memory leaks.

---

## üîç `malloc` vs `new` in C++

| Feature             | `malloc()`                        | `new`                               |
| ------------------- | --------------------------------- | ----------------------------------- |
| Language            | C / C++                           | C++ only                            |
| Syntax              | `malloc(size)`                    | `new Type` / `new Type[size]`       |
| Returns             | `void*` (requires casting in C++) | Typed pointer                       |
| Constructor Called? | ‚ùå No                              | ‚úÖ Yes                               |
| Deallocation        | `free(ptr)`                       | `delete ptr` / `delete[] ptr`       |
| Throws on failure?  | ‚ùå Returns `NULL`                  | ‚úÖ Throws `std::bad_alloc`           |
| Overloadable?       | ‚ùå No                              | ‚úÖ Yes (can overload `new`/`delete`) |

---

## üíª C++ Program: Malloc vs New with Leak Detection

```cpp
#include <iostream>
#include <cstdlib>   // for malloc and free
#include <new>       // for std::nothrow

class MyClass {
public:
    int x;
    MyClass() {
        x = 42;
        std::cout << "Constructor called\n";
    }
    ~MyClass() {
        std::cout << "Destructor called\n";
    }
};

void mallocExample() {
    std::cout << "\n[malloc example]\n";

    // Allocate memory for 5 integers
    int* arr = (int*)malloc(5 * sizeof(int));
    if (arr == nullptr) {
        std::cerr << "malloc failed\n";
        return;
    }

    arr[0] = 100;
    std::cout << "arr[0] = " << arr[0] << "\n";

    // Memory leak (intentional for detection): not calling free(arr)
    // free(arr);  // Uncomment to prevent leak
}

void newExample() {
    std::cout << "\n[new example]\n";

    // Allocate object using new
    MyClass* obj = new(std::nothrow) MyClass();
    if (!obj) {
        std::cerr << "new failed\n";
        return;
    }

    std::cout << "obj->x = " << obj->x << "\n";

    // Memory leak (intentional for detection): not calling delete
    // delete obj;  // Uncomment to prevent leak
}

int main() {
    mallocExample();
    newExample();

    std::cout << "\nRun this program with Valgrind to detect memory leaks:\n";
    std::cout << "valgrind --leak-check=full ./your_program\n";

    return 0;
}
```

---

## ‚úÖ Compile & Run

```bash
g++ -g malloc_vs_new.cpp -o malloc_vs_new
valgrind --leak-check=full ./malloc_vs_new
```

---

## üß™ Sample Valgrind Output (if `free`/`delete` are commented):

```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 20 bytes in 1 blocks
==12345==    definitely lost: 16 bytes in 1 blocks
```

---

## üõ† Fixing Leaks

To fix the memory leaks:

* Add `free(arr);` in `mallocExample()`
* Add `delete obj;` in `newExample()`

---

## ‚úÖ Optional: Use Smart Pointers (Modern C++)

To avoid manual memory management altogether, use:

```cpp
#include <memory>

std::unique_ptr<MyClass> smartObj = std::make_unique<MyClass>();
```

