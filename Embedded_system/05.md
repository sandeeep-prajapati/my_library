Absolutely, Sandeep! Here's a complete **multithreaded C program** that simulates a **ring buffer (circular queue)** using **producer and consumer threads** with **mutex and condition variables**.

---

## ðŸ“˜ **Overview**

* A **ring buffer** (circular queue) of fixed size.
* **Producer thread** adds integers to the buffer.
* **Consumer thread** removes integers from the buffer.
* Thread-safe using `pthread_mutex_t` and `pthread_cond_t`.

---

## ðŸ’» **Code: `ring_buffer_sim.c`**

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 5
#define NUM_ITEMS   20

int buffer[BUFFER_SIZE];
int head = 0, tail = 0;
int count = 0;

pthread_mutex_t lock;
pthread_cond_t not_empty;
pthread_cond_t not_full;

void* producer(void* arg) {
    for (int i = 1; i <= NUM_ITEMS; ++i) {
        pthread_mutex_lock(&lock);

        while (count == BUFFER_SIZE) {
            pthread_cond_wait(&not_full, &lock);
        }

        buffer[tail] = i;
        tail = (tail + 1) % BUFFER_SIZE;
        count++;

        printf("Produced: %d | Buffer size: %d\n", i, count);

        pthread_cond_signal(&not_empty);
        pthread_mutex_unlock(&lock);

        usleep(100000); // simulate production time (100ms)
    }

    return NULL;
}

void* consumer(void* arg) {
    for (int i = 1; i <= NUM_ITEMS; ++i) {
        pthread_mutex_lock(&lock);

        while (count == 0) {
            pthread_cond_wait(&not_empty, &lock);
        }

        int data = buffer[head];
        head = (head + 1) % BUFFER_SIZE;
        count--;

        printf("Consumed: %d | Buffer size: %d\n", data, count);

        pthread_cond_signal(&not_full);
        pthread_mutex_unlock(&lock);

        usleep(150000); // simulate consumption time (150ms)
    }

    return NULL;
}

int main() {
    pthread_t prod_thread, cons_thread;

    pthread_mutex_init(&lock, NULL);
    pthread_cond_init(&not_empty, NULL);
    pthread_cond_init(&not_full, NULL);

    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);

    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);

    pthread_mutex_destroy(&lock);
    pthread_cond_destroy(&not_empty);
    pthread_cond_destroy(&not_full);

    printf("Ring buffer simulation completed.\n");
    return 0;
}
```

---

## âœ… **Compile & Run**

```bash
gcc -pthread ring_buffer_sim.c -o ring_buffer_sim
./ring_buffer_sim
```

---

## ðŸ“Œ **Sample Output**

```
Produced: 1 | Buffer size: 1
Produced: 2 | Buffer size: 2
Consumed: 1 | Buffer size: 1
Produced: 3 | Buffer size: 2
...
Ring buffer simulation completed.
```

---

## ðŸ”§ **Enhancements (Optional)**

* Use dynamic buffer size with `malloc`.
* Add multiple producer/consumer threads.
* Detect buffer overflow/underflow (for testing).
* Log to a file instead of stdout.

Let me know if you'd like a **real hardware sensor** simulated with this buffer or a **GUI-based viewer for buffer status**!
