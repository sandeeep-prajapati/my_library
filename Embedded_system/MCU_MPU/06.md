Here's how to **simulate SPI communication** between a **Master MCU** and a **Slave Sensor** in **pure C**, without actual hardware. This is useful for testing SPI logic on a PC or in a microcontroller simulator.

---

## üß≠ Overview

We simulate:

* **Master** sending data (e.g., command/request)
* **Slave** responding with data (e.g., sensor value)
* Use shared variables to mimic MOSI (Master Out Slave In), MISO (Master In Slave Out), CLK, and CS lines.

---

## üß± SPI Signal Simulation

```c
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>  // for usleep()

// SPI lines
uint8_t MOSI = 0;
uint8_t MISO = 0;
uint8_t CLK  = 0;
uint8_t CS   = 1;  // Active low

// Shared data buffer
uint8_t spi_tx_buffer = 0;
uint8_t spi_rx_buffer = 0;

// Simulated delay (for clock)
#define SPI_DELAY 1000  // in microseconds
```

---

## üßë‚Äçüíª Slave Sensor Code

```c
// Simulated sensor data
uint8_t sensor_data = 0xAB;

// Slave listens on rising clock edge
void slave_listen() {
    static uint8_t bit_count = 0;
    static uint8_t temp_rx = 0;
    static uint8_t temp_tx = 0;

    if (CS == 0 && CLK == 1) {  // Rising edge
        // Read MOSI bit
        temp_rx <<= 1;
        temp_rx |= (MOSI & 0x01);

        // Prepare MISO bit
        MISO = (temp_tx >> 7) & 0x01;
        temp_tx <<= 1;

        bit_count++;

        if (bit_count == 8) {
            printf("[SLAVE] Received byte: 0x%02X\n", temp_rx);
            if (temp_rx == 0x55) {  // Example command from master
                temp_tx = sensor_data;  // Prepare response
            }
            temp_rx = 0;
            bit_count = 0;
        }
    }
}
```

---

## üßë‚Äçüíª Master MCU Code

```c
// Master sends and receives one byte over SPI
uint8_t spi_transfer_byte(uint8_t data_out) {
    uint8_t data_in = 0;

    for (int i = 0; i < 8; i++) {
        // Set MOSI bit
        MOSI = (data_out >> (7 - i)) & 0x01;

        // Toggle CLK low->high
        CLK = 0;
        usleep(SPI_DELAY);
        CLK = 1;

        // Slave reads on CLK high
        slave_listen();

        // Read MISO
        data_in <<= 1;
        data_in |= (MISO & 0x01);

        usleep(SPI_DELAY);

        CLK = 0;
    }

    return data_in;
}
```

---

## üöÄ Main Simulation

```c
int main() {
    printf("[MASTER] Starting SPI communication...\n");

    CS = 0;  // Select slave

    uint8_t command = 0x55;
    uint8_t response = spi_transfer_byte(command);  // Send command

    response = spi_transfer_byte(0x00);  // Dummy byte to read sensor

    CS = 1;  // Deselect slave

    printf("[MASTER] Received response: 0x%02X\n", response);

    return 0;
}
```

---

## üì¶ Output

```txt
[MASTER] Starting SPI communication...
[SLAVE] Received byte: 0x55
[MASTER] Received response: 0xAB
```

---

## üõ†Ô∏è Notes

* You can add file logging or simulate delays better for real-time emulation.
* Add CRC checks or simulate multi-byte frames if needed.
* Expand to simulate DMA SPI or full-duplex streams.

---
