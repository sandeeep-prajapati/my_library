Here‚Äôs how you can **interface a DHT11 temperature and humidity sensor with an 8-bit AVR microcontroller** like ATmega16/32 using plain **C (AVR-GCC)**:

---

### üß∞ **DHT11 Key Characteristics**

* **Single-wire protocol** (bidirectional)
* Start signal from MCU ‚Üí DHT responds with data
* Sends **40 bits** (8 bits √ó 5):

  * **1 byte** humidity integer
  * **1 byte** humidity decimal
  * **1 byte** temperature integer
  * **1 byte** temperature decimal
  * **1 byte** checksum

---

### üîå **Connections**

| DHT11 Pin | AVR Pin           |
| --------- | ----------------- |
| VCC       | 5V                |
| GND       | GND               |
| DATA      | PA0 (or any GPIO) |
| NC        | Not connected     |

---

### üñ•Ô∏è **Code Overview**

We'll use:

* `avr/io.h` for port control
* `util/delay.h` for timing
* A simple GPIO toggle-based timing (not ultra precise)

---

### ‚úÖ **C Code for AVR-GCC (ATmega16/32)**

```c
#include <avr/io.h>
#include <util/delay.h>

#define DHT_DDR  DDRA
#define DHT_PORT PORTA
#define DHT_PIN  PINA
#define DHT_INPUTPIN PA0

uint8_t dht_data[5] = {0};

void Request() {
    DHT_DDR |= (1 << DHT_INPUTPIN); // Set as output
    DHT_PORT &= ~(1 << DHT_INPUTPIN); // Pull low
    _delay_ms(20);  // At least 18ms
    DHT_PORT |= (1 << DHT_INPUTPIN); // Pull high
    _delay_us(30);  // Wait for DHT response
}

void Response() {
    DHT_DDR &= ~(1 << DHT_INPUTPIN); // Set as input
    while(DHT_PIN & (1 << DHT_INPUTPIN)); // Wait for LOW
    while(!(DHT_PIN & (1 << DHT_INPUTPIN))); // Wait for HIGH
    while(DHT_PIN & (1 << DHT_INPUTPIN)); // Wait for LOW again
}

uint8_t Receive_data() {
    uint8_t data = 0;
    for (int i = 0; i < 8; i++) {
        while(!(DHT_PIN & (1 << DHT_INPUTPIN))); // Wait for HIGH
        _delay_us(30);
        if (DHT_PIN & (1 << DHT_INPUTPIN)) {
            data = (data << 1) | 1;
        } else {
            data = (data << 1);
        }
        while(DHT_PIN & (1 << DHT_INPUTPIN)); // Wait for LOW
    }
    return data;
}

int main(void) {
    DDRA = 0xFF;  // For output LEDs (debug)
    while (1) {
        Request();
        Response();
        for (int i = 0; i < 5; i++) {
            dht_data[i] = Receive_data();
        }

        // Simple checksum verification
        if ((dht_data[0] + dht_data[1] + dht_data[2] + dht_data[3]) == dht_data[4]) {
            // Valid data - Toggle LED on PA1 to show success
            PORTA |= (1 << PA1);
            _delay_ms(500);
            PORTA &= ~(1 << PA1);
        }

        _delay_ms(1000); // Wait before next reading
    }
}
```

---

### üß™ **Debugging Tips**

* Use an oscilloscope or logic analyzer to check waveforms.
* Make sure the sensor gets at least **20 ms of LOW signal** from the MCU.
* Ensure accurate delays (not always precise in `_delay_us` at high frequencies).

---

### üîÅ **Optional Enhancements**

* Use **Timer/capture units** for precise pulse width measurements.
* Display values on **LCD** or send via **UART**.
* Integrate with **FreeRTOS** as a task if needed.

---

Let me know if you want:

* An **LCD display version**
* **UART** debug output
* Code for **ATmega328P** (Arduino core compatible)
