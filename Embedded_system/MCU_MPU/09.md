### 🔄 **How DMA Controllers Work in Microcontrollers**

**DMA (Direct Memory Access)** allows peripherals like ADC, SPI, or UART to **transfer data directly to/from memory** (RAM) **without CPU intervention**. This:

* Frees up the CPU to do other tasks
* Enables high-speed data movement
* Reduces latency and power consumption

---

### ✅ **Key DMA Concepts**

| Component         | Description                                                    |
| ----------------- | -------------------------------------------------------------- |
| **Source**        | Peripheral data register (e.g., ADC data register)             |
| **Destination**   | RAM address                                                    |
| **Transfer size** | Number of bytes/words to move                                  |
| **Trigger/Event** | Signals that start the DMA (e.g., ADC end-of-conversion event) |
| **DMA Channel**   | Logical channel configured for a specific peripheral transfer  |
| **Modes**         | Circular, Normal, Burst, Memory-to-Memory                      |

---

### 📌 **Use Case: ADC → RAM with DMA**

**Goal**: Continuously read data from ADC and store in a buffer in RAM using DMA.

---

### 📝 **Pseudo-code: ADC to RAM via DMA**

```c
#define ADC_BUFFER_SIZE  100
uint16_t adc_buffer[ADC_BUFFER_SIZE];  // Buffer in RAM

void configure_ADC_DMA() {
    // 1. Enable clocks for DMA and ADC
    enable_clock(DMA1);
    enable_clock(ADC1);

    // 2. Configure ADC
    ADC1->CHANNEL = CHANNEL_0; // Select channel
    ADC1->MODE = CONTINUOUS;   // Continuous conversion mode
    ADC1->DMA_ENABLE = 1;      // Enable DMA for ADC

    // 3. Configure DMA
    DMA1_Channel1->CPAR  = &ADC1->DR;         // Source: ADC data register
    DMA1_Channel1->CMAR  = adc_buffer;        // Destination: RAM buffer
    DMA1_Channel1->CNDTR = ADC_BUFFER_SIZE;   // Number of transfers
    DMA1_Channel1->CCR   = PERIPHERAL_TO_MEMORY |
                           MEMORY_INCREMENT |
                           CIRCULAR_MODE |
                           ENABLE;

    // 4. Start ADC
    ADC1->START = 1;
}
```

---

### 🧠 **Explanation of Key Flags**

* `PERIPHERAL_TO_MEMORY`: Direction of data
* `MEMORY_INCREMENT`: Increment RAM address for each value
* `CIRCULAR_MODE`: Restart DMA after reaching buffer end (good for continuous data)
* `ENABLE`: Start the DMA channel

---

### ✅ **Real-World Microcontrollers Support This:**

* **STM32** (e.g., `HAL_ADC_Start_DMA()` in HAL library)
* **NXP LPC series**
* **TI MSP430 and Tiva-C**
* **AVR XMEGA with DMA controller**

---

### 🧪 Tip: Debugging DMA

* Watch DMA interrupt/status flags
* Ensure memory is properly aligned
* Use `volatile` for DMA buffers to avoid compiler optimizations

---
