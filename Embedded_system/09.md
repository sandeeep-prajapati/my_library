Here is a complete C program to **parse a custom binary protocol packet** using `struct` and `union`:

---

### ðŸ§© Problem Statement:

Suppose we have a custom binary protocol with the following packet structure:

```
Byte 0:  Header (0xAA)
Byte 1:  Command ID
Byte 2:  Payload Length (N)
Byte 3-N+2: Payload
Last Byte: Checksum (Header ^ Command ID ^ Length ^ Payload bytes)
```

---

### âœ… Objective:

Parse the incoming binary stream and extract each field into a structure, validate checksum, and display the contents.

---

### ðŸ“Œ Code:

```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

#define MAX_PAYLOAD_SIZE 256

// Custom packet structure
typedef struct {
    uint8_t header;
    uint8_t command_id;
    uint8_t length;
    uint8_t payload[MAX_PAYLOAD_SIZE];
    uint8_t checksum;
} CustomPacket;

// Union for raw and structured access
typedef union {
    uint8_t raw[MAX_PAYLOAD_SIZE + 5];  // header + command + length + payload + checksum
    CustomPacket packet;
} PacketUnion;

// Function to calculate checksum
uint8_t calculate_checksum(const CustomPacket* pkt) {
    uint8_t cs = pkt->header ^ pkt->command_id ^ pkt->length;
    for (int i = 0; i < pkt->length; i++) {
        cs ^= pkt->payload[i];
    }
    return cs;
}

// Function to parse a raw byte stream
int parse_packet(const uint8_t* data, size_t size, CustomPacket* out) {
    if (size < 5) return -1; // Minimum size check

    if (data[0] != 0xAA) return -2; // Invalid header

    uint8_t length = data[2];
    if (size != (length + 4)) return -3; // Size mismatch

    out->header = data[0];
    out->command_id = data[1];
    out->length = length;
    memcpy(out->payload, &data[3], length);
    out->checksum = data[3 + length];

    if (calculate_checksum(out) != out->checksum) return -4; // Invalid checksum

    return 0; // Success
}

// Display packet
void print_packet(const CustomPacket* pkt) {
    printf("Header     : 0x%02X\n", pkt->header);
    printf("Command ID : 0x%02X\n", pkt->command_id);
    printf("Length     : %d\n", pkt->length);
    printf("Payload    : ");
    for (int i = 0; i < pkt->length; i++) {
        printf("0x%02X ", pkt->payload[i]);
    }
    printf("\nChecksum   : 0x%02X\n", pkt->checksum);
}

// Example usage
int main() {
    // Simulated raw packet: header=0xAA, command=0x01, length=3, payload={0x10, 0x20, 0x30}
    uint8_t raw_data[] = {0xAA, 0x01, 0x03, 0x10, 0x20, 0x30, 0xAA ^ 0x01 ^ 0x03 ^ 0x10 ^ 0x20 ^ 0x30};

    CustomPacket pkt;
    int result = parse_packet(raw_data, sizeof(raw_data), &pkt);

    if (result == 0) {
        printf("Packet parsed successfully:\n");
        print_packet(&pkt);
    } else {
        printf("Error parsing packet: %d\n", result);
    }

    return 0;
}
```

---

### ðŸ’¡ Key Concepts Demonstrated:

* Usage of `union` for raw and structured memory access.
* Parsing binary data with pointer arithmetic.
* Bitwise operations for checksum.
* Buffer size validation to prevent overflow.

---