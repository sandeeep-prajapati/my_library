Sure, Sandeep! Here's a clean and modular **C++ class** that simulates an **I2C communication interface**, including basic read/write operations and slave address handling.

This simulation doesn't talk to real hardware but gives you an extensible **software model** for I2C communication.

---

### ðŸ“˜ **I2C Concepts Recap**

* **Master** initiates communication.
* **Slave** responds with its address.
* **Read/Write** operations happen with address, register, and data.

---

### ðŸ’» **C++ Code â€“ `I2CInterface` Class**

```cpp
#include <iostream>
#include <map>
#include <vector>
#include <iomanip>

class I2CDevice {
public:
    virtual void writeRegister(uint8_t reg, uint8_t data) = 0;
    virtual uint8_t readRegister(uint8_t reg) = 0;
};

class I2CInterface {
private:
    std::map<uint8_t, I2CDevice*> devices; // Map of slave address to device

public:
    void attachDevice(uint8_t address, I2CDevice* device) {
        devices[address] = device;
        std::cout << "Device attached at address 0x" << std::hex << int(address) << std::endl;
    }

    void write(uint8_t address, uint8_t reg, uint8_t data) {
        if (devices.find(address) != devices.end()) {
            devices[address]->writeRegister(reg, data);
            std::cout << "Write to device 0x" << std::hex << int(address)
                      << ", reg 0x" << int(reg) << " <- 0x" << int(data) << std::endl;
        } else {
            std::cout << "Device not found at address 0x" << std::hex << int(address) << std::endl;
        }
    }

    uint8_t read(uint8_t address, uint8_t reg) {
        if (devices.find(address) != devices.end()) {
            uint8_t value = devices[address]->readRegister(reg);
            std::cout << "Read from device 0x" << std::hex << int(address)
                      << ", reg 0x" << int(reg) << " -> 0x" << int(value) << std::endl;
            return value;
        } else {
            std::cout << "Device not found at address 0x" << std::hex << int(address) << std::endl;
            return 0xFF;
        }
    }
};

class TemperatureSensor : public I2CDevice {
private:
    std::map<uint8_t, uint8_t> registers;

public:
    TemperatureSensor() {
        registers[0x00] = 25;  // Temp register
        registers[0x01] = 0xAB; // ID register
    }

    void writeRegister(uint8_t reg, uint8_t data) override {
        registers[reg] = data;
    }

    uint8_t readRegister(uint8_t reg) override {
        return registers.count(reg) ? registers[reg] : 0x00;
    }
};

// Example usage
int main() {
    I2CInterface i2cBus;

    TemperatureSensor sensor;
    uint8_t sensorAddr = 0x48;

    i2cBus.attachDevice(sensorAddr, &sensor);

    // Write to sensor
    i2cBus.write(sensorAddr, 0x01, 0xCD);

    // Read from sensor
    uint8_t id = i2cBus.read(sensorAddr, 0x01);
    uint8_t temp = i2cBus.read(sensorAddr, 0x00);

    std::cout << "Sensor ID: 0x" << std::hex << int(id) << std::endl;
    std::cout << "Temperature: " << std::dec << int(temp) << "Â°C" << std::endl;

    return 0;
}
```

---

### ðŸ§ª **Output**

```
Device attached at address 0x48
Write to device 0x48, reg 0x1 <- 0xcd
Read from device 0x48, reg 0x1 -> 0xcd
Read from device 0x48, reg 0x0 -> 0x19
Sensor ID: 0xcd
Temperature: 25Â°C
```

---

### ðŸ”§ **You Can Extend This With**

* Support for multi-byte transfers
* Simulating clock stretching, ACK/NACK
* Multiple sensor types (e.g., `EEPROM`, `Accelerometer`)
* Time-based data updates for real-time simulation

