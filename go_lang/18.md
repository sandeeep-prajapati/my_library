Nice — let’s build a clean, well-explained TCP server & client in Go. I’ll give you two practical examples you can copy/run:

1. A simple newline-delimited **echo server** + client (easy to test from terminal).
2. A more robust **concurrent server** with graceful shutdown and a **length-prefixed** message framing protocol (safer for binary data / predictable reads), plus a client that demonstrates both sending and receiving.

I’ll explain each piece as we go. Code is ready-to-run.

# Simple newline-delimited Echo Server (server.go)

This is the minimal, idiomatic TCP server: accepts connections, handles each connection concurrently, reads lines, echoes them back.

```go
// server_simple.go
package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"net"
)

func handleConn(conn net.Conn) {
	defer conn.Close()
	addr := conn.RemoteAddr().String()
	log.Println("connected:", addr)

	reader := bufio.NewReader(conn)
	writer := bufio.NewWriter(conn)

	for {
		// Read until newline
		line, err := reader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				log.Println("client disconnected:", addr)
			} else {
				log.Println("read error:", err)
			}
			return
		}

		log.Printf("recv from %s: %q", addr, line)

		// Echo back
		_, err = writer.WriteString("echo: " + line)
		if err != nil {
			log.Println("write error:", err)
			return
		}
		writer.Flush()
	}
}

func main() {
	listenAddr := ":9000"
	ln, err := net.Listen("tcp", listenAddr)
	if err != nil {
		log.Fatalf("listen error: %v", err)
	}
	log.Println("echo server listening on", listenAddr)

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Println("accept error:", err)
			continue
		}
		go handleConn(conn) // handle each client concurrently
	}
}
```

## How to run

1. `go run server_simple.go`
2. In another terminal: `nc localhost 9000` (or `telnet localhost 9000`) then type lines. The server will reply prefixed with `echo: `.

## Explanation — key points

* `net.Listen("tcp", addr)` creates a TCP listener.
* `ln.Accept()` waits for an incoming connection and returns a `net.Conn`.
* Each connection gets a goroutine `go handleConn(conn)`, so server can handle many clients concurrently.
* `bufio.Reader.ReadString('\n')` reads until newline — good for human-readable text protocols.
* Always `defer conn.Close()` to free resources.

---

# Robust concurrent TCP server with graceful shutdown + length-prefixed framing

This version:

* Uses a length-prefixed protocol (4-byte big-endian length) so messages can contain arbitrary bytes (including newlines).
* Has a connection manager and a clean shutdown on SIGINT / SIGTERM.
* Broadcasts server messages to connected clients (example of sending messages from server side).
* Shows how to avoid blocking writes (per-connection send channel).

Files: `server.go` and `client.go` (below).

## Server (server.go)

```go
// server.go
package main

import (
	"context"
	"encoding/binary"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

// writeMessage sends a length-prefixed message (4-byte uint32 BE length + payload)
func writeMessage(w io.Writer, data []byte) error {
	var lenBuf [4]byte
	binary.BigEndian.PutUint32(lenBuf[:], uint32(len(data)))
	if _, err := w.Write(lenBuf[:]); err != nil {
		return err
	}
	_, err := w.Write(data)
	return err
}

// readMessage reads a length-prefixed message
func readMessage(r io.Reader) ([]byte, error) {
	var lenBuf [4]byte
	if _, err := io.ReadFull(r, lenBuf[:]); err != nil {
		return nil, err
	}
	n := binary.BigEndian.Uint32(lenBuf[:])
	if n == 0 {
		return []byte{}, nil
	}
	data := make([]byte, n)
	_, err := io.ReadFull(r, data)
	return data, err
}

type client struct {
	conn net.Conn
	send chan []byte
	addr string
}

type server struct {
	ln        net.Listener
	clients   map[*client]struct{}
	mu        sync.Mutex
	wg        sync.WaitGroup
	broadcast chan []byte
}

func newServer() *server {
	return &server{
		clients:   make(map[*client]struct{}),
		broadcast: make(chan []byte, 128),
	}
}

func (s *server) addClient(c *client) {
	s.mu.Lock()
	s.clients[c] = struct{}{}
	s.mu.Unlock()
}

func (s *server) removeClient(c *client) {
	s.mu.Lock()
	delete(s.clients, c)
	s.mu.Unlock()
	close(c.send)
}

func (s *server) runBroadcaster(ctx context.Context) {
	for {
		select {
		case msg := <-s.broadcast:
			// broadcast to all clients (non-blocking)
			s.mu.Lock()
			for c := range s.clients {
				select {
				case c.send <- msg:
				default:
					// client's send buffer full: drop client to avoid blocking
					log.Println("dropping client (send buffer full):", c.addr)
					go func(cl *client) {
						cl.conn.Close()
					}(c)
				}
			}
			s.mu.Unlock()
		case <-ctx.Done():
			return
		}
	}
}

func (s *server) handleConn(ctx context.Context, conn net.Conn) {
	c := &client{
		conn: conn,
		send: make(chan []byte, 64),
		addr: conn.RemoteAddr().String(),
	}
	s.addClient(c)
	s.wg.Add(1)
	defer s.wg.Done()
	defer s.removeClient(c)
	defer conn.Close()

	log.Println("client connected:", c.addr)

	// writer goroutine
	writeDone := make(chan struct{})
	go func() {
		defer close(writeDone)
		for {
			select {
			case data, ok := <-c.send:
				if !ok {
					return
				}
				if err := writeMessage(conn, data); err != nil {
					log.Println("write error to", c.addr, err)
					return
				}
			case <-ctx.Done():
				return
			}
		}
	}()

	// read loop
	for {
		msg, err := readMessage(conn)
		if err != nil {
			if err == io.EOF {
				log.Println("client disconnected:", c.addr)
			} else {
				log.Println("read error:", c.addr, err)
			}
			break
		}
		log.Printf("recv from %s: %s", c.addr, string(msg))
		// Example: reply to sender and broadcast to everyone
		reply := []byte(fmt.Sprintf("server-recv: %s", string(msg)))
		select {
		case c.send <- reply:
		default:
			log.Println("client send buffer full, dropping reply to", c.addr)
		}

		// broadcast message to all clients
		bcast := []byte(fmt.Sprintf("[%s] %s", c.addr, string(msg)))
		s.broadcast <- bcast
	}

	// wait for writer to finish
	conn.Close()
	<-writeDone
	log.Println("connection handler done for", c.addr)
}

func (s *server) ListenAndServe(addr string) error {
	var err error
	s.ln, err = net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	log.Println("server listening on", addr)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// broadcaster
	go s.runBroadcaster(ctx)

	// accept loop
	for {
		conn, err := s.ln.Accept()
		if err != nil {
			// If listener closed, return
			if opErr, ok := err.(*net.OpError); ok && opErr.Err.Error() == "use of closed network connection" {
				return nil
			}
			log.Println("accept error:", err)
			continue
		}
		go s.handleConn(ctx, conn)
	}
}

// Shutdown closes listener and waits for active handlers to finish with timeout.
func (s *server) Shutdown(timeout time.Duration) {
	log.Println("shutdown: closing listener")
	if s.ln != nil {
		s.ln.Close()
	}

	done := make(chan struct{})
	go func() {
		s.wg.Wait()
		close(done)
	}()

	select {
	case <-done:
		log.Println("shutdown: all handlers finished")
	case <-time.After(timeout):
		log.Println("shutdown: timeout waiting for handlers")
	}
}

func main() {
	srv := newServer()
	go func() {
		if err := srv.ListenAndServe(":9001"); err != nil {
			log.Println("server stopped:", err)
		}
	}()

	// example: server side periodic message (every 10s)
	go func() {
		t := time.NewTicker(10 * time.Second)
		for range t.C {
			srv.broadcast <- []byte("server-broadcast: heartbeat")
		}
	}()

	// graceful shutdown on SIGINT / SIGTERM
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)
	<-stop
	log.Println("got signal, shutting down...")
	srv.Shutdown(5 * time.Second)
	log.Println("server exit")
}
```

### Key design decisions & explanations

* **Length-prefixed framing**: `writeMessage` writes a 4-byte big-endian length followed by payload. `readMessage` reads exactly that many bytes. This avoids problems when payload contains newlines or binary.
* **Per-client send channel**: avoids concurrent writes to the same `net.Conn`. A single writer goroutine is responsible for writing to the network for that connection.
* **Backpressure / drop policy**: when `client.send` buffer is full we drop the client or drop the message to avoid blocking the whole server. You can change this policy depending on requirements.
* **Graceful shutdown**: `Shutdown` closes listener and waits for active handlers via `sync.WaitGroup`. We wait up to a timeout.
* **Broadcast channel**: the server has a central `broadcast` channel; any handler can push messages to it and `runBroadcaster` fan-outs to clients.
* **Context**: used to stop goroutines on server context cancellation (not fully used in this snippet but included pattern-wise).

---

## Client demonstrating the length-prefixed protocol (client.go)

```go
// client.go
package main

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"io"
	"log"
	"net"
	"os"
)

func writeMessage(w io.Writer, data []byte) error {
	var lenBuf [4]byte
	binary.BigEndian.PutUint32(lenBuf[:], uint32(len(data)))
	if _, err := w.Write(lenBuf[:]); err != nil {
		return err
	}
	_, err := w.Write(data)
	return err
}

func readMessage(r io.Reader) ([]byte, error) {
	var lenBuf [4]byte
	if _, err := io.ReadFull(r, lenBuf[:]); err != nil {
		return nil, err
	}
	n := binary.BigEndian.Uint32(lenBuf[:])
	if n == 0 {
		return []byte{}, nil
	}
	data := make([]byte, n)
	_, err := io.ReadFull(r, data)
	return data, err
}

func main() {
	conn, err := net.Dial("tcp", "localhost:9001")
	if err != nil {
		log.Fatal("dial error:", err)
	}
	defer conn.Close()
	fmt.Println("connected to server")

	// start a goroutine to read messages from server
	go func() {
		for {
			msg, err := readMessage(conn)
			if err != nil {
				if err == io.EOF {
					log.Println("server closed connection")
					os.Exit(0)
				}
				log.Println("read error:", err)
				os.Exit(1)
			}
			fmt.Println("RECV:", string(msg))
		}
	}()

	// read from stdin and send to server
	scanner := bufio.NewScanner(os.Stdin)
	fmt.Print("Enter text> ")
	for scanner.Scan() {
		text := scanner.Text()
		if text == "quit" || text == "exit" {
			fmt.Println("exiting")
			return
		}
		if err := writeMessage(conn, []byte(text)); err != nil {
			log.Println("write error:", err)
			return
		}
		fmt.Print("Enter text> ")
	}

	if err := scanner.Err(); err != nil {
		log.Println("stdin error:", err)
	}
}
```

### How to run the robust example

1. `go run server.go`
2. `go run client.go` (in another terminal). Type lines and hit enter. Server will echo and broadcast messages. Type `exit` to quit the client.

---

# Common pitfalls & tips

* **Concurrent writes**: never write to the same `net.Conn` from multiple goroutines. Use a single writer goroutine or synchronize writes with a mutex.
* **Framing**: TCP is a stream — reads may return partial messages. Use a framing strategy: newline-delimited, length-prefix, or higher-level protocols (HTTP/gRPC).
* **Dead connections**: use application-level heartbeats or set deadlines (e.g., `conn.SetDeadline`) to detect dead peers.
* **TLS**: for production, wrap connections with `tls.Config` and `tls.Listen` / `tls.Dial` for secure transport.
* **Performance**: for very high connection counts consider tuning OS limits (ulimit), use `epoll`-backed network event loops (Go's runtime handles this) and evaluate resource usage.
* **Backpressure**: design what to do when clients are slow: buffer, block, or drop — each has trade-offs.
* **Timeouts**: set read & write deadlines to avoid goroutines stuck forever on dead sockets.

---

# Quick comparison of the two approaches

* **Newline-delimited**: great for simple human-facing text protocols. Easy to debug with `nc`. But fails if payload includes newlines or arbitrary binary.
* **Length-prefixed**: robust for arbitrary payloads and binary data. Slightly more code but production-ready.

---
