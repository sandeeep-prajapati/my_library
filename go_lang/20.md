Here’s a **clear, practical, beginner-friendly** guide to **benchmarking Go functions using `testing.B`**, followed by **multiple examples**, including tips and common pitfalls.

---

# ✅ **1. What is Benchmarking in Go?**

Benchmarking helps you *measure the performance* of your Go code.

Go’s testing package has built-in benchmark support.

A benchmark function:

* Must start with `Benchmark`
* Must accept a pointer `*testing.B`
* Uses a loop `for i := 0; i < b.N; i++ { ... }`
* Automatically adjusts `b.N` to get stable results

---

# ✅ **2. Basic Benchmark Example**

### **File: `math.go`**

```go
package mathx

func Add(a, b int) int {
    return a + b
}
```

### **File: `math_test.go`**

```go
package mathx

import "testing"

func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(5, 10)
    }
}
```

### Run the benchmark:

```
go test -bench=.
```

### Output (sample):

```
BenchmarkAdd-8     1000000000     0.266 ns/op
```

* **8** → number of CPU threads used
* **1000000000** → iterations run
* **0.266 ns/op** → nanoseconds per operation

---

# ✅ **3. Realistic Example: Benchmarking String Concatenation**

### File: `stringx.go`

```go
package stringx

func Concat(a, b string) string {
    return a + b
}
```

### File: `stringx_test.go`

```go
package stringx

import "testing"

func BenchmarkConcat(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Concat("hello", "world")
    }
}
```

Run:

```
go test -bench=Concat
```

---

# ✅ **4. Writing Multiple Benchmarks in the Same File**

```go
func BenchmarkAddSmall(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(1, 2)
    }
}

func BenchmarkAddLarge(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(100000000, 999999999)
    }
}
```

---

# ✅ **5. Table-Driven Benchmarks**

Same pattern as table-driven tests.

```go
func BenchmarkTable(b *testing.B) {
    cases := []struct {
        name string
        a, b int
    }{
        {"small", 1, 2},
        {"medium", 1000, 2000},
        {"large", 1000000, 2000000},
    }

    for _, tc := range cases {
        b.Run(tc.name, func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                Add(tc.a, tc.b)
            }
        })
    }
}
```

Run:

```
go test -bench=BenchmarkTable -benchmem
```

---

# ✅ **6. Benchmark Memory Allocations**

Use `-benchmem`:

```
go test -bench=. -benchmem
```

Output:

```
BenchmarkConcat-8   50000000   25.0 ns/op   8 B/op   1 allocs/op
```

* **8 B/op** → bytes allocated per op
* **1 allocs/op** → allocations per op

This helps you optimize memory-heavy functions.

---

# ✅ **7. Benchmarking Functions With Setup (Use `b.ResetTimer`)**

If your function needs heavy setup, don’t include setup time in the benchmark.

### Example:

```go
func BenchmarkSliceAppend(b *testing.B) {
    b.StopTimer()
    base := make([]int, 0, 1000)
    b.StartTimer()

    for i := 0; i < b.N; i++ {
        _ = append(base, i)
    }
}
```

Or simpler:

```go
b.ResetTimer() // resets timing + allocation counters
```

---

# ✅ **8. Benchmarking Parallel Code**

Go supports benchmarking parallel workloads:

```go
func BenchmarkParallelAdd(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            Add(10, 20)
        }
    })
}
```

Runs multiple goroutines to simulate concurrency.

---

# ✅ **9. Avoid Benchmark Pitfalls**

| Mistake                                       | Why it's wrong                        |
| --------------------------------------------- | ------------------------------------- |
| Doing I/O inside benchmark                    | IO is slow and noisy, ruins benchmark |
| Using random numbers                          | Randomness makes results inconsistent |
| Logging inside benchmark                      | Slows down dramatically               |
| Memory allocation inside loop unless required | Inflates allocations/op               |
| Using time.Sleep                              | Never do this inside a benchmark      |

---

# ✅ **10. Benchmark Example With Real Use Case: Sorting**

```go
func BenchmarkSort(b *testing.B) {
    for i := 0; i < b.N; i++ {
        data := []int{5, 3, 6, 1, 9, 8}
        sort.Ints(data)
    }
}
```

---
