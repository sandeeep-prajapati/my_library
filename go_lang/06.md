
---

# âœ… **Using Function Closures in Go (with real-world examples)**

Closures in Go are functions **that capture variables from their surrounding scope**, even after that scope has ended.

In simple terms:

> **A closure is a function + the environment it remembers.**

---

# ðŸ§© **1. Basic Closure Example**

```go
package main

import "fmt"

func counter() func() int {
    count := 0  // captured variable

    return func() int {
        count++
        return count
    }
}

func main() {
    c := counter()
    fmt.Println(c()) // 1
    fmt.Println(c()) // 2
    fmt.Println(c()) // 3
}
```

âœ” `count` lives even after `counter()` returns
âœ” Each call updates the same captured variable

---

# ðŸ§© **2. Closure with Parameters**

```go
func multiplier(x int) func(int) int {
    return func(y int) int {
        return x * y
    }
}

func main() {
    double := multiplier(2)
    triple := multiplier(3)

    fmt.Println(double(10)) // 20
    fmt.Println(triple(10)) // 30
}
```

---

# ðŸ”¥ **Real-World Use Cases for Closures**

Below are **the 6 places closures are actually useful** in real-world Go projects.

---

# ðŸ§  **Use Case 1 â€” Creating Configurable Functions (API, ML, Tools)**

Closures are great to **create functions with preloaded settings**.

### Example: logging with prefix

```go
func makeLogger(prefix string) func(string) {
    return func(msg string) {
        fmt.Println(prefix, msg)
    }
}

func main() {
    info := makeLogger("[INFO]")
    errLog := makeLogger("[ERROR]")

    info("server started")
    errLog("db not reachable")
}
```

---

# ðŸ›’ **Use Case 2 â€” Rate Limiting (Throttle API calls)**

Closures let you store state between calls.

```go
func rateLimiter(limit int) func() bool {
    count := 0
    return func() bool {
        if count < limit {
            count++
            return true
        }
        return false
    }
}
```

---

# ðŸŽ® **Use Case 3 â€” Event Handlers in GUI / WebAssembly**

(Closures are widely used in JS; Go's WASM uses same pattern.)

```go
func clickHandler() func() {
    clicks := 0
    return func() {
        clicks++
        fmt.Println("Clicked:", clicks)
    }
}
```

---

# ðŸ§ª **Use Case 4 â€” Mocking State in Unit Tests**

Store test-specific state inside a closure.

```go
func fakeDB() func(string) string {
    store := map[string]string{
        "101": "User A",
    }
    return func(id string) string {
        return store[id]
    }
}
```

---

# âš™ **Use Case 5 â€” Functional Pipelines / Middleware**

Closures are perfect for chaining middleware (HTTP servers, gRPC, etc.)

```go
func middleware(next func(int) int) func(int) int {
    return func(x int) int {
        fmt.Println("before")
        out := next(x)
        fmt.Println("after")
        return out
    }
}
```

---

# ðŸ“Š **Use Case 6 â€” Simple in-memory Caching**

```go
func memoize(f func(int) int) func(int) int {
    cache := make(map[int]int)
    return func(n int) int {
        if v, ok := cache[n]; ok {
            return v
        }
        result := f(n)
        cache[n] = result
        return result
    }
}
```

---

# ðŸ† **When You Should Use Closures in Real Projects**

| When                                         | Why closures help                              |
| -------------------------------------------- | ---------------------------------------------- |
| You need a function that **remembers state** | counters, caching, rate limiting               |
| You want **configurable functions**          | preloaded loggers, preconfigured services      |
| You build **middleware**                     | HTTP/gRPC chains                               |
| You want **cleaner test mocks**              | stateful fake DBs, mock counters               |
| You want to **hide data**                    | closures provide encapsulation without classes |

---

# ðŸŽ¯ Summary (super short)

* **Closures = Function + Remembered Environment**
* They help create **stateful functions** without classes.
* Used in: caching, rate limiting, middleware, mocks, logging, pipelines.

---
