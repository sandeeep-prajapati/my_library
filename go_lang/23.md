Below is a **clear, practical, and production-ready guide** on how to organize a **large Go project using Clean Architecture**.
This is the exact structure used in real-world enterprise Go services.

---

# âœ… **Clean Architecture for Large Go Projects**

Clean Architecture splits your code into independent layers:

```
[ Presentation / Interface ]  â†’  [ Application / Use-cases ]  â†’  [ Domain ]  â†’  [ Infrastructure ]
```

* **Domain** = business rules, entities, interfaces
* **Usecases** = pure application logic
* **Interface/Handlers** = HTTP, gRPC, CLI, WebSocket, worker, etc.
* **Infrastructure** = DB, external APIs, frameworks, drivers

The **outer layers depend on inner layers**, NEVER the reverse.

---

# ğŸ“ **1. Folder Structure (Industry Standard)**

```
project/
â”‚
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ main.go
â”‚
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”‚   â”œâ”€â”€ entity.go
â”‚   â”‚   â”‚   â””â”€â”€ repository.go
â”‚   â”‚   â””â”€â”€ common/
â”‚   â”‚       â””â”€â”€ errors.go
â”‚   â”‚
â”‚   â”œâ”€â”€ usecase/
â”‚   â”‚   â””â”€â”€ user/
â”‚   â”‚       â”œâ”€â”€ create_user.go
â”‚   â”‚       â”œâ”€â”€ get_user.go
â”‚   â”‚       â””â”€â”€ service.go
â”‚   â”‚
â”‚   â”œâ”€â”€ interface/
â”‚   â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â”‚   â”œâ”€â”€ user_handler.go
â”‚   â”‚   â”‚   â””â”€â”€ router.go
â”‚   â”‚   â””â”€â”€ grpc/
â”‚   â”‚
â”‚   â””â”€â”€ infrastructure/
â”‚       â”œâ”€â”€ db/
â”‚       â”‚   â”œâ”€â”€ pg_user_repo.go
â”‚       â”‚   â””â”€â”€ connection.go
â”‚       â”œâ”€â”€ logger/
â”‚       â””â”€â”€ env/
â”‚
â”œâ”€â”€ pkg/   (optional shared utilities)
â””â”€â”€ go.mod
```

---

# ğŸš€ Let's Build a Feature: **User Management**

We'll implement:

* Domain entity
* Repository interface
* Use case service
* HTTP handler
* PostgreSQL repository

---

# ğŸŒ± 2. **Domain Layer**

Pure business objects, no frameworks.

### **internal/domain/user/entity.go**

```go
package user

type User struct {
    ID    int64
    Name  string
    Email string
}
```

### **internal/domain/user/repository.go**

```go
package user

type Repository interface {
    Create(u *User) error
    GetByID(id int64) (*User, error)
}
```

ğŸ‘‰ This interface is used by the use case.
ğŸ‘‰ The database will implement this interface.

---

# âš™ï¸ 3. **Use Case Layer**

Business workflows (CreateUser, GetUser).

### **internal/usecase/user/service.go**

```go
package user

import "project/internal/domain/user"

type Service struct {
    repo user.Repository
}

func NewService(r user.Repository) *Service {
    return &Service{repo: r}
}
```

### **internal/usecase/user/create_user.go**

```go
func (s *Service) CreateUser(name, email string) error {
    u := &user.User{Name: name, Email: email}
    return s.repo.Create(u)
}
```

### **internal/usecase/user/get_user.go**

```go
func (s *Service) GetUser(id int64) (*user.User, error) {
    return s.repo.GetByID(id)
}
```

**Usecases depend only on domain interfaces.**

---

# ğŸŒ 4. **Interface Layer (HTTP)**

### **internal/interface/http/user_handler.go**

```go
package http

import (
    "encoding/json"
    "net/http"
    "strconv"

    "project/internal/usecase/user"
)

type UserHandler struct {
    service *user.Service
}

func NewUserHandler(s *user.Service) *UserHandler {
    return &UserHandler{service: s}
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    var req struct {
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    json.NewDecoder(r.Body).Decode(&req)

    if err := h.service.CreateUser(req.Name, req.Email); err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }

    w.WriteHeader(http.StatusCreated)
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    idStr := r.URL.Query().Get("id")
    id, _ := strconv.ParseInt(idStr, 10, 64)

    user, err := h.service.GetUser(id)
    if err != nil {
        w.WriteHeader(http.StatusInternalServerError)
        return
    }

    json.NewEncoder(w).Encode(user)
}
```

### **internal/interface/http/router.go**

```go
func RegisterRoutes(mux *http.ServeMux, h *UserHandler) {
    mux.HandleFunc("/users", h.CreateUser)
    mux.HandleFunc("/user", h.GetUser)
}
```

---

# ğŸ§± 5. **Infrastructure Layer (PostgreSQL)**

### **internal/infrastructure/db/pg_user_repo.go**

```go
package db

import (
    "database/sql"
    "project/internal/domain/user"
)

type PgUserRepo struct {
    DB *sql.DB
}

func NewPgUserRepo(db *sql.DB) *PgUserRepo {
    return &PgUserRepo{DB: db}
}

func (r *PgUserRepo) Create(u *user.User) error {
    _, err := r.DB.Exec("INSERT INTO users(name, email) VALUES ($1,$2)", u.Name, u.Email)
    return err
}

func (r *PgUserRepo) GetByID(id int64) (*user.User, error) {
    row := r.DB.QueryRow("SELECT id, name, email FROM users WHERE id=$1", id)
    var u user.User
    if err := row.Scan(&u.ID, &u.Name, &u.Email); err != nil {
        return nil, err
    }
    return &u, nil
}
```

---

# ğŸš€ 6. **Wire Everything Together in `cmd/api/main.go`**

### **cmd/api/main.go**

```go
package main

import (
    "database/sql"
    "log"
    "net/http"

    _ "github.com/lib/pq"

    httpif "project/internal/interface/http"
    "project/internal/infrastructure/db"
    usecase "project/internal/usecase/user"
)

func main() {
    conn, err := sql.Open("postgres", "postgres://user:pass@localhost/dbname?sslmode=disable")
    if err != nil { panic(err) }

    repo := db.NewPgUserRepo(conn)
    service := usecase.NewService(repo)
    handler := httpif.NewUserHandler(service)

    mux := http.NewServeMux()
    httpif.RegisterRoutes(mux, handler)

    log.Println("Server running on :8080")
    http.ListenAndServe(":8080", mux)
}
```

---

# ğŸ¯ Why This Architecture Works

| Benefit       | Explanation                                                      |
| ------------- | ---------------------------------------------------------------- |
| **Testable**  | You can mock the repo for use-case tests.                        |
| **Decoupled** | Database, HTTP, gRPC can be swapped without touching core logic. |
| **Scalable**  | New features are added as new domain + usecases + handlers.      |
| **Clean**     | Code has clear responsibility boundaries.                        |

---
