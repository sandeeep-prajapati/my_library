Here is a **practical, engineer-friendly guide to memory optimization techniques in Go**, with **clear explanations, diagrams, and example code** you can use in real projects.

---

# ğŸš€ **1. Avoid Unnecessary Allocations**

### âŒ Slow (allocates every iteration)

```go
func bad() []int {
    var out []int
    for i := 0; i < 10000; i++ {
        out = append(out, i) // repeatedly grows, causing many allocations
    }
    return out
}
```

### âœ… Fast (pre-allocate with capacity)

```go
func good() []int {
    out := make([]int, 0, 10000) // capacity known â†’ no resizing
    for i := 0; i < 10000; i++ {
        out = append(out, i)
    }
    return out
}
```

### ğŸ’¡ Why?

Growing slices reallocates memory â†’ **expensive heap operations**.

---

# ğŸš€ **2. Avoid Slicing Large Arrays (Memory Leak Pattern)**

This is a *classic Go footgun*.

### âŒ Problem: slicing holds reference to the entire underlying array

```go
func leak() []byte {
    big := make([]byte, 10<<20) // 10 MB
    small := big[:10]           // holds entire 10MB in memory
    return small
}
```

Even though you return 10 bytes, **the 10MB cannot be freed**.

### âœ… Solution: copy into a new small slice

```go
func noLeak() []byte {
    big := make([]byte, 10<<20)
    small := make([]byte, 10)
    copy(small, big[:10])
    return small
}
```

---

# ğŸš€ **3. Use `sync.Pool` to Reuse Heavy Objects**

Good for big buffers, JSON encoders, etc.

### Example

```go
var bufPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024) // 1KB buffer
    },
}

func handler() {
    buf := bufPool.Get().([]byte)
    defer bufPool.Put(buf)

    // use buffer...
}
```

### When to use:

âœ” High throughput
âœ” Objects expensive to allocate
âœ” Short-lived and reusable

### When NOT to use:

âŒ Long-lived data
âŒ Objects with state that must be reset

---

# ğŸš€ **4. Reduce Allocations with `bytes.Buffer` or `strings.Builder`**

### âŒ Inefficient string concatenation (allocates each time)

```go
s := ""
for i := 0; i < 10000; i++ {
    s += "x"
}
```

### âœ… Using `strings.Builder`

```go
var b strings.Builder
b.Grow(10000)
for i := 0; i < 10000; i++ {
    b.WriteByte('x')
}
s := b.String()
```

---

# ğŸš€ **5. Avoid Interface Conversions & Escape to Heap**

### Example: Variables escape to heap when returned as `interface{}`

```go
func box(i int) interface{} {
    return i // escapes to heap
}
```

Heap allocations are more expensive.

### Solution

Use concrete types wherever possible.

---

# ğŸš€ **6. Use Value Receivers When Methods Do Not Mutate**

### âŒ Using pointer forces heap escapes for small objects:

```go
type Point struct {
    X, Y int
}

func (p *Point) Print() {
    fmt.Println(p.X, p.Y)
}
```

### âœ… Use value receivers when possible

```go
func (p Point) Print() {
    fmt.Println(p.X, p.Y)
}
```

Value receiver â†’ stored on stack â†’ fewer heap allocations.

---

# ğŸš€ **7. Reuse Byte Slices Instead of Creating New Ones**

### âŒ Allocates new slice each time:

```go
data := make([]byte, 0)
```

### âœ… Reuse existing slices

```go
data = data[:0] // reset length but keep capacity
```

This is especially useful in tight loops.

---

# ğŸš€ **8. Avoid Large Struct Copies â€” Use Pointers**

### âŒ Copying a huge struct costs memory and CPU:

```go
type Big struct {
    Data [1 << 20]byte // 1MB
}

func process(b Big) {} // copies 1MB each call
```

### âœ… Use pointer receiver

```go
func process(b *Big) {}
```

---

# ğŸš€ **9. Use Maps Carefully â€” They Allocate More Than You Think**

### Important rules:

âœ” Use `make(map[...], capacity)` if size is predictable
âœ” Use `delete(m, key)` to allow reuse
âœ” Avoid storing large structs inside maps â†’ use pointers

Example:

```go
m := make(map[string]*User, 1000)
```

---

# ğŸš€ **10. Tune the Garbage Collector (`GOGC`)**

### What is `GOGC`?

Controls how often GC runs.

```
GOGC=100 (default): normal frequency  
GOGC=200: runs less often â†’ lower CPU, more memory  
GOGC=50: runs more often â†’ less memory, more CPU  
```

### Example: reduce memory usage

```bash
export GOGC=50
```

---

# ğŸš€ **11. Zero Allocation Techniques in Hot Paths**

### Example: scanning JSON without allocating

```go
var s string
json.Unmarshal(data, &s)  // allocates

// but...
scan := []byte(s)  // reuse memory
```

Use:

* `unsafe.String()` (Go 1.20+)
* `bytes.Clone()`
* `sync.Pool` reusable buffers

To eliminate garbage.

---

# ğŸš€ **12. Use Profiling Tools (Very Important)**

### Memory profile:

```bash
go test -run=none -bench=. -benchmem
```

### pprof:

```bash
go tool pprof -http=:8080 mem.out
```

Find:

* escaped variables
* large allocations
* slice growth hotspots

---

# ğŸ“Š **Memory Leak Diagram**

```
Big slice (cap=10MB)
  |
  +-- small := big[:10]
            â†‘
      Still holds reference to entire 10MB
```

---
