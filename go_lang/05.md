Here are **5 advanced, interview-ready, interface-based design challenges in Go**, each followed by **optimal solutions**.
These challenges teach **polymorphism, dependency injection, interface composition, mocking, and clean architecture**.

---

# ‚≠ê **Challenge 1: Logging System with Multiple Backends**

**Goal:**
Design a logging system that supports **ConsoleLogger**, **FileLogger**, and **NoOpLogger** (used for testing).

### **Requirements**

* Common interface: `Logger` with method `Log(msg string)`
* Application must accept any logger
* Demonstrate switching between loggers

---

## ‚úÖ **Solution**

```go
package main

import (
    "fmt"
    "os"
)

type Logger interface {
    Log(msg string)
}

type ConsoleLogger struct{}

func (ConsoleLogger) Log(msg string) {
    fmt.Println("[Console]", msg)
}

type FileLogger struct {
    file *os.File
}

func NewFileLogger(filepath string) *FileLogger {
    f, _ := os.Create(filepath)
    return &FileLogger{file: f}
}

func (l *FileLogger) Log(msg string) {
    l.file.WriteString(msg + "\n")
}

type NoOpLogger struct{}

func (NoOpLogger) Log(msg string) {} // does nothing

func Process(logger Logger) {
    logger.Log("Task started")
}

func main() {
    Process(ConsoleLogger{})
    Process(NewFileLogger("log.txt"))
    Process(NoOpLogger{})
}
```

### **Concepts learned**

* Interface polymorphism
* Swappable dependencies
* NoOp pattern for testing

---

# ‚≠ê **Challenge 2: Payment Gateway Strategy**

**Goal:**
Implement a **strategy pattern** using interfaces:

* `PayPal`
* `Stripe`
* `CashOnDelivery`

### **Requirements**

* `PaymentGateway` interface with `Pay(amount float64) string`
* A checkout function using the interface

---

## ‚úÖ **Solution**

```go
package main

import "fmt"

type PaymentGateway interface {
    Pay(amount float64) string
}

type PayPal struct{}
func (PayPal) Pay(amount float64) string { return "Paid via PayPal" }

type Stripe struct{}
func (Stripe) Pay(amount float64) string { return "Paid via Stripe" }

type COD struct{}
func (COD) Pay(amount float64) string { return "Cash On Delivery selected" }

func Checkout(pg PaymentGateway) {
    fmt.Println(pg.Pay(500))
}

func main() {
    Checkout(PayPal{})
    Checkout(Stripe{})
    Checkout(COD{})
}
```

### **Concepts learned**

* Strategy pattern
* Decoupling payment logic from business logic

---

# ‚≠ê **Challenge 3: Custom Sorter (Like sort.Interface)**

**Goal:**
Create your own sorter that works on **any collection** that satisfies a custom interface.

### **Requirements**

* Interface `Sortable` with:

  * `Len() int`
  * `Swap(i, j int)`
  * `Less(i, j int) bool`
* Implement a Bubble Sort using the interface
* Demonstrate sorting custom types

---

## ‚úÖ **Solution**

```go
package main

import "fmt"

type Sortable interface {
    Len() int
    Swap(i, j int)
    Less(i, j int) bool
}

func BubbleSort(s Sortable) {
    n := s.Len()
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if s.Less(j+1, j) {
                s.Swap(j, j+1)
            }
        }
    }
}

// Custom Type
type Numbers []int

func (n Numbers) Len() int           { return len(n) }
func (n Numbers) Swap(i, j int)      { n[i], n[j] = n[j], n[i] }
func (n Numbers) Less(i, j int) bool { return n[i] < n[j] }

func main() {
    nums := Numbers{5, 1, 4, 2, 3}
    BubbleSort(nums)
    fmt.Println(nums)
}
```

### **Concepts learned**

* Interface-based generic algorithms
* Behavior abstraction
* How `sort.Interface` works internally

---

# ‚≠ê **Challenge 4: Storage Interface (Local, Memory, Cloud Mock)**

**Goal:**
Design a flexible storage system with 3 implementations:

* In-memory storage
* Local file storage
* Mock storage for unit tests

### **Requirements**

* Interface: `Storage { Save(key, value string) }`
* Implement 3 versions
* Use dependency injection

---

## ‚úÖ **Solution**

```go
package main

import (
    "fmt"
    "os"
)

type Storage interface {
    Save(key, value string)
}

// Memory Storage
type MemoryStore map[string]string

func (m MemoryStore) Save(key, value string) {
    m[key] = value
}

// File Storage
type FileStore struct {
    file *os.File
}

func NewFileStore(p string) *FileStore {
    f, _ := os.Create(p)
    return &FileStore{file: f}
}

func (fs *FileStore) Save(key, value string) {
    fs.file.WriteString(key + "=" + value + "\n")
}

// Mock Storage for Testing
type MockStore struct{}

func (MockStore) Save(key, value string) {
    fmt.Println("Mock save:", key, value)
}

func writeUserData(s Storage) {
    s.Save("user", "sandeep")
}

func main() {
    writeUserData(MemoryStore{})
    writeUserData(NewFileStore("data.txt"))
    writeUserData(MockStore{})
}
```

### **Concepts learned**

* Dependency injection
* Real-world storage abstraction
* Test mocking patterns

---

# ‚≠ê **Challenge 5: Observer Pattern (Event System)**

**Goal:**
Implement an event system where multiple observers can listen for updates.

### **Requirements**

* `Listener` interface with method `Update(data string)`
* `EventBus` struct that maintains a list of listeners
* Notify all listeners when an event occurs

---

## ‚úÖ **Solution**

```go
package main

import "fmt"

type Listener interface {
    Update(data string)
}

type EventBus struct {
    listeners []Listener
}

func (bus *EventBus) Register(l Listener) {
    bus.listeners = append(bus.listeners, l)
}

func (bus *EventBus) Broadcast(msg string) {
    for _, l := range bus.listeners {
        l.Update(msg)
    }
}

type EmailListener struct{}
func (EmailListener) Update(data string) {
    fmt.Println("Email:", data)
}

type SMSListener struct{}
func (SMSListener) Update(data string) {
    fmt.Println("SMS:", data)
}

func main() {
    bus := EventBus{}
    bus.Register(EmailListener{})
    bus.Register(SMSListener{})

    bus.Broadcast("New User Registered!")
}
```

### **Concepts learned**

* Observer pattern
* Event-driven design
* Interface-based extensibility

---

# üéØ **Final Summary**

You learned **5 advanced interface design patterns**:

### ‚úî Logging abstraction

### ‚úî Strategy pattern

### ‚úî Generic sorting

### ‚úî Dependency injection for storages

### ‚úî Observer/event-bus pattern

All of these are used in **real-world Go applications**, including backend systems, microservices, and cloud-native apps.

---
