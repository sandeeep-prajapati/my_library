Here is a clean, complete explanation of **Go‚Äôs error-handling philosophy** along with **custom error type examples**.

---

# ‚úÖ **Go‚Äôs Error Handling Philosophy**

Go‚Äôs error handling is **explicit**, **simple**, and **predictable**.
Unlike languages such as Java, Python, or C++, Go **does not use exceptions** for normal error flow.

### üî• Core Principles

### **1. Errors are values**

In Go, an error is just a value that implements:

```go
type error interface {
    Error() string
}
```

Errors are returned like any other value.

---

### **2. No try/catch ‚Äî check errors explicitly**

Instead of exception blocks, Go encourages you to check errors every time:

```go
data, err := readFile("config.json")
if err != nil {
    return err
}
```

This makes error handling:

* predictable
* visible
* easier to reason about

---

### **3. Fail early, return fast**

Functions usually return early when something goes wrong:

```go
if err != nil {
    return err
}
```

This avoids deep nesting.

---

### **4. Context matters ‚Äî wrap errors**

Go encourages adding context:

```go
return fmt.Errorf("failed to open config: %w", err)
```

`%w` enables error unwrapping (`errors.Is`, `errors.As`).

---

### **5. Sentinel errors exist, but avoid too many**

You can define a global error:

```go
var ErrUserNotFound = errors.New("user not found")
```

But Go devs recommend using **wrapping** instead to prevent brittle code.

---

### **6. Prefer custom error types for rich info**

When you need more than a message‚Äîlike an error code‚Äîdefine a struct.

---

# ‚úÖ **Custom Error Types in Go (Examples)**

Below are different styles you MUST know.

---

## **1Ô∏è‚É£ Simple Custom Error Type**

### Example: Validation Error

```go
package main

import (
    "fmt"
)

type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed on %s: %s", e.Field, e.Message)
}

func validateAge(age int) error {
    if age < 18 {
        return &ValidationError{
            Field:   "age",
            Message: "must be at least 18",
        }
    }
    return nil
}
```

Usage:

```go
err := validateAge(10)
fmt.Println(err)
```

---

## **2Ô∏è‚É£ Rich Error With Code**

Useful for APIs.

```go
type APIError struct {
    Code    int
    Message string
}

func (e *APIError) Error() string {
    return fmt.Sprintf("API error %d: %s", e.Code, e.Message)
}

func GetUser(id int) error {
    if id == 0 {
        return &APIError{Code: 404, Message: "user not found"}
    }
    return nil
}
```

---

## **3Ô∏è‚É£ Wrap Errors With Context (Recommended)**

```go
func readConfig(path string) error {
    data, err := os.ReadFile(path)
    if err != nil {
        return fmt.Errorf("readConfig: %w", err)
    }
    _ = data
    return nil
}
```

Unwrap with:

```go
if errors.Is(err, os.ErrNotExist) {
    fmt.Println("File does not exist!")
}
```

---

## **4Ô∏è‚É£ Custom Error With Time Information**

```go
type TimeoutError struct {
    Operation string
    Duration  time.Duration
}

func (e *TimeoutError) Error() string {
    return fmt.Sprintf("%s timed out after %s", e.Operation, e.Duration)
}
```

---

## **5Ô∏è‚É£ Domain-Specific Error System Example**

Imagine a payment system:

```go
type PaymentError struct {
    Code       string
    Amount     float64
    Additional string
}

func (e *PaymentError) Error() string {
    return fmt.Sprintf("Payment error [%s]: amount=%.2f %s",
        e.Code, e.Amount, e.Additional)
}

func Charge(amount float64) error {
    if amount <= 0 {
        return &PaymentError{
            Code:       "INVALID_AMOUNT",
            Amount:     amount,
            Additional: "must be greater than zero",
        }
    }
    return nil
}
```

---

# üß† **When to Use Custom Errors in Go**

Use custom error types when you need to:

‚úî attach metadata (codes, fields, timestamps)
‚úî identify a specific error type via `errors.As`
‚úî differentiate errors programmatically
‚úî build APIs or large-scale applications

---

# ‚≠ê Final Summary

| Feature          | Go‚Äôs Philosophy                          |
| ---------------- | ---------------------------------------- |
| Errors mechanism | Errors are **values**, not exceptions    |
| Handling         | Always **explicit** with `if err != nil` |
| Wrapping         | Use `fmt.Errorf("... %w", err)`          |
| Sentinel errors  | Ok in small cases, avoid many            |
| Custom errors    | Use struct-based errors for metadata     |

---
