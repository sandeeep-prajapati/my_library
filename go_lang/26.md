Here is a **simple, clear, and diagram-rich explanation** of **how the Go Garbage Collector (GC)** works.
The diagrams are **ASCII-style** so you can easily visualize the internals.

---

# üß† **Go‚Äôs Garbage Collector: High-Level View**

Go uses:

### **‚Ä¢ A concurrent**,

### **‚Ä¢ tri-color**,

### **‚Ä¢ mark-and-sweep garbage collector**,

### **‚Ä¢ with a write barrier**,

### **‚Ä¢ designed for low pauses (~<1ms).**

It runs **alongside your program (goroutines)** and only pauses briefly.

---

# üß© **1. Memory Layout Diagram**

```
+-------------------------------+
|            HEAP               |
|  (objects allocated via new)  |
+-------------------------------+

+-------------------------------+
|            STACKS             |
|  (goroutine stack frames)     |
+-------------------------------+

Program roots = { global vars, stacks, CPU registers }
```

The **GC starts at the roots** and traces reachable heap objects.

---

# üé® **2. Tri-Color GC Model (Core Concept)**

Objects are divided into 3 colors:

```
WHITE   = Unvisited (candidate for deletion)
GRAY    = Reachable but children not scanned yet
BLACK   = Reachable and fully scanned
```

### Diagram:

```
        +-------------+       +------------+       +-----------+
        |   WHITE     | --->  |   GRAY     | --->  |   BLACK   |
        |  (dead?)    |       |  (pending) |       |  (live)   |
        +-------------+       +------------+       +-----------+
```

At the end of GC:

```
ALL WHITE OBJECTS = garbage (freeable)
```

---

# ‚öôÔ∏è **3. Step-by-Step Go GC Cycle**

## **Step 1 ‚Äî Mark Start (brief stop-the-world)**

Go pauses the world for ~0.1‚Äì1ms:

* It stops goroutines momentarily.
* It identifies **root references**.

üìå Diagram:

```
ROOTS:
+---------+    +----------+
| Global  |    | Stacks   |
| Vars    |    | (goroutines)
+---------+    +----------+
```

All root-reachable objects become **gray**.

---

## **Step 2 ‚Äî Marking (concurrent)**

Goroutines resume.

The GC works in the background:

```
[GRAY objects] ‚Üí scan ‚Üí turn BLACK ‚Üí mark children GRAY
```

Diagram:

```
    (Gray Queue)
         |
         v
     +--------+         +-----------+
     |  GRAY  | ----->  |  BLACK    |
     | object |         | scanned   |
     +--------+         +-----------+
          |
          | marks
          v
     +----------+
     | children |
     |   GRAY   |
     +----------+
```

---

## **Step 3 ‚Äî Write Barrier (while marking)**

When your program modifies a pointer, Go intercepts it.

### Why?

To maintain tri-color invariants.

### Diagram (simplified):

```
App write: A.black ‚Üí B.white

Write barrier:
    mark B as GRAY
```

---

## **Step 4 ‚Äî Sweep Phase (background)**

After marking, we know:

* **BLACK = live**
* **WHITE = garbage**

Diagram:

```
HEAP BLOCK:
+---------+---------+---------+
| BLACK   | WHITE   | WHITE   |  ‚Üê white blocks freed
+---------+---------+---------+
```

Go returns memory to free lists.

---

# üß† **4. Visualization of an Entire GC Cycle**

```
START GC
   |
   v
[Root Scan] (STW small pause)
   |
   v
[Mark: gray ‚Üí black]  (concurrent)
   |
   +-- write barrier keeps objects gray when needed
   |
   v
[Mark Done] (STW small pause)
   |
   v
[Sweep unmarked objects]
   |
   v
END GC
```

---

# üïí **5. GC Pacing (How Go decides when to run GC)**

Go tries to keep:

```
heap_growth / live_heap <= GOGC (default 100%)
```

Meaning:

* If live objects = 100 MB
* GC tries to run before heap > 200 MB

### Diagram:

```
live heap = 100MB
       |
       |    GC runs here
       v
heap reaches ~200MB
```

You can tune using:

```bash
GOGC=50   # more frequent GC
GOGC=200  # less frequent GC
GOGC=off  # disable GC
```

---

# ‚ö° **6. Go Garbage Collector Timeline Diagram**

```
Time -->
+--------+--------------------+---------+
|  STW   |  concurrent mark   |   STW   |
| (short)|  + write barrier   | (short) |
+--------+--------------------+---------+
                     \
                      +--- concurrent sweep
```

---

# üî¨ **7. Example With Objects**

Suppose you have:

```
A ‚Üí B ‚Üí C
D  (unreachable)
```

Initial state:

```
A,B,C = reachable
D = unreachable

colors:
A,B,C = WHITE
D = WHITE
```

Mark roots:

```
A = GRAY
```

Scan A:

```
A = BLACK
B = GRAY
```

Scan B:

```
B = BLACK
C = GRAY
```

Scan C:

```
C = BLACK
```

Final:

```
BLACK: A, B, C
WHITE: D  (deleted)
```

Sweep removes D.

---

# üéØ **8. Why Go‚Äôs GC Is Fast**

* No full stop-the-world cycle
* Uses write barrier
* Incremental + concurrent mark
* Small pause times
* Parallel sweep
* Efficient span + bitmap memory layout

---

# üß© **9. Go GC in One Diagram**

```
        +------------------------------+
        |    Concurrent Mark-Sweep GC  |
        +------------------------------+
        | 1. Small STW: root marking   |
        | 2. Concurrent mark (gray‚Üíblack)
        | 3. Write barrier maintains invariants
        | 4. Small STW: mark termination
        | 5. Concurrent sweep (free white)
        +------------------------------+
```

---
