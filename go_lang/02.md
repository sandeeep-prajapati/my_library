
---

# âœ… **What Are Structs in Go?**

`struct` is a **custom data type** that lets you group related fields.

```go
type User struct {
    Name  string
    Email string
    Age   int
}
```

Structs are the foundation of Goâ€™s data modeling.

---

# âœ… **What Are Interfaces in Go?**

An **interface** defines a set of method signatures.
Any type that implements those methods **implicitly** satisfies the interface.

```go
type Notifier interface {
    Notify(msg string) error
}
```

No â€œimplementsâ€ keyword â†’ fully **implicit**.
This makes Go interfaces extremely flexible.

---

# ğŸš€ Now let's learn with **5 real-world examples**.

---

# -----------------------------------------

# **ğŸŒ Example 1: User Authentication System**

### **Struct â†’ User**

### **Interface â†’ AuthService**

### **Use Case:** Login, signup, etc.

```go
type User struct {
    ID       int
    Username string
    Password string
}

// Interface for authentication actions
type AuthService interface {
    Login(username, password string) bool
    Signup(u User) error
}

type LocalAuth struct{}

func (LocalAuth) Login(username, password string) bool {
    return username == "admin" && password == "1234"
}

func (LocalAuth) Signup(u User) error {
    println("User signed up:", u.Username)
    return nil
}
```

### Why is this real-world?

* `AuthService` allows swapping e.g. **LocalAuth**, **FirebaseAuth**, **OAuth service**.

---

# -----------------------------------------

# **ğŸ“¦ Example 2: Payment Gateway Integration**

### **Structs â†’ Razorpay, Paytm**

### **Interface â†’ PaymentGateway**

```go
type PaymentGateway interface {
    Pay(amount float64) string
}

type Razorpay struct{}

func (Razorpay) Pay(amount float64) string {
    return "Paid â‚¹" + fmt.Sprint(amount) + " using Razorpay"
}

type Paytm struct{}

func (Paytm) Pay(amount float64) string {
    return "Paid â‚¹" + fmt.Sprint(amount) + " using Paytm"
}
```

### Use Case

You can switch payment provider **without changing business logic**:

```go
func Checkout(pg PaymentGateway) {
    println(pg.Pay(999.99))
}

Checkout(Razorpay{}) // Works
Checkout(Paytm{})    // Also works
```

---

# -----------------------------------------

# **ğŸ“§ Example 3: Email Sender**

### **Interface â†’ Mailer**

### **Structs â†’ GmailService, SMTPService**

```go
type Mailer interface {
    Send(to, subject, body string) error
}

type GmailService struct{}

func (GmailService) Send(to, subject, body string) error {
    println("Sent via Gmail to:", to)
    return nil
}

type SMTPService struct{}

func (SMTPService) Send(to, subject, body string) error {
    println("Sent via SMTP to:", to)
    return nil
}
```

### Real-world benefit:

Swap Gmail â†” SMTP â†” SendGrid without changing your API server.

---

# -----------------------------------------

# **ğŸš— Example 4: Vehicle Speed Calculation**

### **Structs â†’ Car, Bike**

### **Interface â†’ Vehicle**

```go
type Vehicle interface {
    Speed() int
}

type Car struct {
    HorsePower int
}

func (c Car) Speed() int {
    return c.HorsePower * 2
}

type Bike struct {
    CC int
}

func (b Bike) Speed() int {
    return b.CC * 1
}
```

### Why real-world?

This pattern is used in:

* Game engines
* Fleet management systems
* Simulations

```go
func PrintSpeed(v Vehicle) {
    println("Speed:", v.Speed())
}

PrintSpeed(Car{HorsePower: 200})
PrintSpeed(Bike{CC: 150})
```

---

# -----------------------------------------

# **ğŸŒ Example 5: Web Framework â€“ Router Handlers**

### **Interface â†’ Handler**

Exactly like **net/http**.

```go
type Handler interface {
    Serve()
}

type HomeHandler struct{}
func (HomeHandler) Serve() { println("Welcome to Home Page") }

type AboutHandler struct{}
func (AboutHandler) Serve() { println("About Page") }
```

Router function:

```go
func Route(h Handler) {
    h.Serve()
}

Route(HomeHandler{})
Route(AboutHandler{})
```

### Real-world use:

This is how **http.Handler** works in Goâ€™s standard library.

---

# ğŸ¯ **Quick Summary**

## ğŸ“Œ **Structs**

* Group related fields.
* Represent data models.
* Can have methods.

## ğŸ“Œ **Interfaces**

* Describe *behavior*, not data.
* Implicit implementation (no keywords).
* Enable dependency injection.
* Make code flexible, replaceable, testable.

---

