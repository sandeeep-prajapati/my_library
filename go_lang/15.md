Below is a **beginner-friendly, complete, production-style guide** on building a **REST API in Go using only `net/http` â€” absolutely NO frameworks**.

This gives you a solid foundation for mastering Go backend development.

---

# ğŸš€ **1. Project Structure**

```
go-rest-api/
â”‚â”€â”€ main.go
â”‚â”€â”€ handlers/
â”‚     â””â”€â”€ user.go
â”‚â”€â”€ models/
â”‚     â””â”€â”€ user.go
â”‚â”€â”€ storage/
â”‚     â””â”€â”€ memory.go
```

Simple, clean, scalable.

---

# ğŸš€ **2. Create a Basic HTTP Server**

`main.go`

```go
package main

import (
    "log"
    "net/http"
)

func main() {
    mux := http.NewServeMux()

    // Register routes
    mux.HandleFunc("/users", usersHandler)
    mux.HandleFunc("/users/", userByIDHandler)

    log.Println("Server running on :8080")
    http.ListenAndServe(":8080", mux)
}
```

âœ” `http.NewServeMux()` = router
âœ” `ListenAndServe` starts the server

---

# ğŸ§± **3. Create a User Model**

`models/user.go`

```go
package models

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}
```

---

# ğŸ—‚ **4. Simple In-Memory Storage (No database)**

`storage/memory.go`

```go
package storage

import "go-rest-api/models"

var Users = []models.User{
    {ID: 1, Name: "Sandeep", Email: "san@example.com"},
    {ID: 2, Name: "Raj", Email: "raj@example.com"},
}
```

---

# ğŸš¥ **5. Implement Handlers (Core Logic)**

## ğŸ“Œ **5.1 GET /users â€” list all users**

`handlers/user.go`

```go
package main

import (
    "encoding/json"
    "net/http"
    "go-rest-api/storage"
)

func usersHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method == "GET" {
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(storage.Users)
        return
    }

    http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
}
```

---

## ğŸ“Œ **5.2 GET /users/{id} â€” fetch one user**

```go
func userByIDHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "GET" {
        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
        return
    }

    // Extract ID from URL
    idStr := r.URL.Path[len("/users/"):]
    id, _ := strconv.Atoi(idStr)

    // Search user
    for _, user := range storage.Users {
        if user.ID == id {
            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(user)
            return
        }
    }

    http.NotFound(w, r)
}
```

---

# âœï¸ **6. POST /users â€” create a new user**

```go
func usersHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case "GET":
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(storage.Users)

    case "POST":
        var user models.User
        json.NewDecoder(r.Body).Decode(&user)

        // Set ID
        user.ID = len(storage.Users) + 1
        storage.Users = append(storage.Users, user)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)

    default:
        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
    }
}
```

---

# ğŸ›  **7. PUT /users/{id} â€” update user**

```go
func userByIDHandler(w http.ResponseWriter, r *http.Request) {
    idStr := r.URL.Path[len("/users/"):]
    id, _ := strconv.Atoi(idStr)

    switch r.Method {
    case "GET":
        for _, user := range storage.Users {
            if user.ID == id {
                json.NewEncoder(w).Encode(user)
                return
            }
        }
        http.NotFound(w, r)

    case "PUT":
        var updated models.User
        json.NewDecoder(r.Body).Decode(&updated)

        for i, user := range storage.Users {
            if user.ID == id {
                updated.ID = id
                storage.Users[i] = updated
                json.NewEncoder(w).Encode(updated)
                return
            }
        }
        http.NotFound(w, r)

    default:
        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
    }
}
```

---

# âŒ **8. DELETE /users/{id} â€” delete user**

```go
case "DELETE":
    for i, user := range storage.Users {
        if user.ID == id {
            storage.Users = append(storage.Users[:i], storage.Users[i+1:]...)
            w.WriteHeader(http.StatusNoContent)
            return
        }
    }
    http.NotFound(w, r)
```

---

# ğŸ§ª **9. Test Your API With curl**

### Get all users:

```
curl http://localhost:8080/users
```

### Create user:

```
curl -X POST -d '{"name":"Amit","email":"amit@gmail.com"}' \
     -H "Content-Type: application/json" \
     http://localhost:8080/users
```

---

# âš¡ Bonus â€” Middleware (Logging Example)

```go
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        log.Printf("%s %s", r.Method, r.URL.Path)
        next.ServeHTTP(w, r)
    })
}
```

Usage:

```go
mux := http.NewServeMux()
mux.HandleFunc("/users", usersHandler)
mux.HandleFunc("/users/", userByIDHandler)

http.ListenAndServe(":8080", LoggingMiddleware(mux))
```

---

# ğŸ’ Summary â€” What You Learned

You now know how to build a REST API in Go using only:

âœ” `net/http`
âœ” `ServeMux`
âœ” Handlers
âœ” JSON encoding/decoding
âœ” URL path parsing
âœ” CRUD operations
âœ” Middleware
âœ” In-memory storage

This is the **foundation** of all Go backend frameworks (Gin, Echo, Fiber).

---
