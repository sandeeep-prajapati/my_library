Hereâ€™s a **clear, simple, beginner-friendly** explanation of the **Go race detector**, with **buggy code**, the **race detector output**, and the **fixed version**.

---

# âœ… **1. What is the Go Race Detector?**

The race detector finds **data races**, which happen when:

* Two or more goroutines access the **same memory**
* At least one writes
* They run **without synchronization**

Run with:

```
go run -race main.go
```

Or for tests:

```
go test -race .
```

---

# âœ… **2. Buggy Code With a Data Race**

Here is a small Go program that *definitely* causes a race:

### **File: `main.go`**

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    count := 0 // shared variable

    for i := 0; i < 5; i++ {
        go func() {
            count++ // unsynchronized write
        }()
    }

    time.Sleep(time.Second)
    fmt.Println("Final count:", count)
}
```

### âŒ Whatâ€™s wrong?

* Multiple goroutines write to `count`
* No mutex / sync mechanism
* The result will be inconsistent

---

# âœ… **3. Run the Race Detector**

```
go run -race main.go
```

### Sample Output:

```
==================
WARNING: DATA RACE
Write at 0x00c000014088 by goroutine 7:
  main.main.func1()
      /home/user/main.go:14 +0x44
Previous read at 0x00c000014088 by main goroutine:
  main.main()
      /home/user/main.go:18 +0x60
...
==================
Found 1 data race(s)
exit status 66
```

The race detector:

* Shows the exact line numbers
* Shows which goroutine did the writing
* Shows that the main goroutine read the same variable

---

# âœ… **4. Fixing the Data Race (Using Mutex)**

### **Corrected Code**

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    count := 0
    var mu sync.Mutex
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            count++
            mu.Unlock()
        }()
    }

    wg.Wait()
    fmt.Println("Final count:", count)
}
```

### Run again:

```
go run -race main.go
```

Output:

```
Final count: 5
```

âœ” No race
âœ” Correct result
âœ” Predictable behavior

---

# âœ… **5. Another Common Data Race Example (Reading & Writing)**

### **Buggy Code**

```go
package main

import "fmt"

var shared = 0

func main() {
    go func() {
        shared = 100
    }()

    fmt.Println(shared) // read without synchronization
}
```

Run:

```
go run -race main.go
```

Data race detected!

---

# ðŸ›  Fix with `sync/atomic`

```go
package main

import (
    "fmt"
    "sync/atomic"
)

var shared int64

func main() {
    atomic.StoreInt64(&shared, 100)
    fmt.Println(atomic.LoadInt64(&shared))
}
```

---
