Here is the **clearest and most practical explanation of `context.Context` in Go**, followed by **real diagrams** and **a complete cancellation example**.

---

# âœ… **What is `context.Context`?**

`context.Context` is Goâ€™s built-in mechanism for:

### âœ” Cancelling goroutines

### âœ” Setting deadlines / timeouts

### âœ” Passing request-scoped values

Contexts are **immutable** and form a **tree**.
When a parent context is cancelled, all its children get cancelled **instantly**.

---

# ðŸ“Œ **Context Tree Diagram (How it Actually Works)**

```
context.Background()
        |
        +-- ctxA (WithCancel)
        |         |
        |         +-- ctxA1 (child goroutine)
        |         +-- ctxA2 (child goroutine)
        |
        +-- ctxB (WithTimeout)
                  |
                  +-- ctxB1 (DB Query)
```

If `ctxA` is cancelled â†’ **ctxA1 and ctxA2 receive the cancellation signal**.
`ctxB` is unaffected because itâ€™s a different branch.

---

# ðŸ§  **Key Attributes of a Context**

| Method       | Meaning                                                   |
| ------------ | --------------------------------------------------------- |
| `Done()`     | Returns a channel closed on cancellation                  |
| `Err()`      | Returns reason: `context.Canceled` or `deadline exceeded` |
| `Deadline()` | Time when context will cancel automatically               |
| `Value()`    | Used for request-scoped data (but avoid over-use)         |

---

# ðŸ”¥ **Types of Contexts**

### 1. **context.Background()**

Root context â†’ empty / never cancelled.

### 2. **context.TODO()**

Use when you *donâ€™t yet know* what context to use.

### 3. **context.WithCancel(parent)**

Manual cancellation.

### 4. **context.WithTimeout(parent, time.Duration)**

Auto-cancel after duration.

### 5. **context.WithDeadline(parent, time.Time)**

Auto-cancel at specific time.

### 6. **context.WithValue(parent, key, value)**

Attach request-scoped values.

---

# ðŸš€ **Build a Cancellation Example (Simple & Clear)**

Weâ€™ll create:

* A parent context with cancellation
* A worker goroutine that listens for cancellation
* We cancel after 2 seconds

---

# âœ… **Complete Working Go Code (with comments)**

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func worker(ctx context.Context) {
	for {
		select {
		case <-ctx.Done(): // cancellation signal
			fmt.Println("Worker stopped:", ctx.Err())
			return
		default:
			fmt.Println("Working...")
			time.Sleep(500 * time.Millisecond)
		}
	}
}

func main() {
	// Create cancellable context
	ctx, cancel := context.WithCancel(context.Background())

	// Start worker
	go worker(ctx)

	// Run for 2 seconds
	time.Sleep(2 * time.Second)

	// Cancel context
	fmt.Println("Cancelling context...")
	cancel()

	// Wait to show output
	time.Sleep(1 * time.Second)
}
```

---

# ðŸ–¼ **Flow Diagram of This Example**

```
main()
  |
  |-- ctx, cancel := WithCancel
  |
  |-- start worker goroutine
  |
  |-- sleep 2s
  |
  |-- cancel() --------------------------+
                                          |
worker():                                 |
  loop:                                    |
    default: "Working..." (500ms)         |
    <-ctx.Done()  <-----------------------+
         print: "Worker stopped: context canceled"
```

---

# â›” Why You MUST Use Context in Real Projects

Contexts are essential for:

### âœ” HTTP servers

Cancel requests when client disconnects.

### âœ” Database queries

Timeouts prevent hanging queries.

### âœ” Microservices

Propagate cancellation across service calls.

### âœ” Preventing goroutine leaks

Contexts avoid goroutines running forever.

---

# ðŸŽ¯ **Bonus: Context Timeout Example**

```go
ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
defer cancel()

select {
case <-time.After(2 * time.Second):
    fmt.Println("Finished work")
case <-ctx.Done():
    fmt.Println("Timed out:", ctx.Err())
}
```

Output:

```
Timed out: context deadline exceeded
```

---

