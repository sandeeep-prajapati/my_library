Below is a clean, production-style **CRUD API using Gin + PostgreSQL**, with migrations, folder structure, and full code.

---

# âœ… **Gin + PostgreSQL CRUD API (Users Example)**

### **Features**

* Create, Read, Update, Delete users
* PostgreSQL connection
* Environment variables
* Repository + Service + Handler clean structure
* Error handling
* JSON input validation

---

# ğŸ“ **Folder Structure**

```
go-gin-crud/
â”‚â”€â”€ cmd/
â”‚   â””â”€â”€ main.go
â”‚â”€â”€ config/
â”‚   â””â”€â”€ config.go
â”‚â”€â”€ db/
â”‚   â””â”€â”€ migrate.go
â”‚â”€â”€ handlers/
â”‚   â””â”€â”€ user_handler.go
â”‚â”€â”€ models/
â”‚   â””â”€â”€ user.go
â”‚â”€â”€ repository/
â”‚   â””â”€â”€ user_repo.go
â”‚â”€â”€ service/
â”‚   â””â”€â”€ user_service.go
â”‚â”€â”€ go.mod
â”‚â”€â”€ .env
```

---

# ğŸ“Œ **1. go.mod**

```go
module go-gin-crud

go 1.22

require (
    github.com/gin-gonic/gin v1.10.0
    github.com/joho/godotenv v1.5.1
    github.com/jackc/pgx/v5 v5.5.0
)
```

---

# ğŸ“Œ **2. .env**

```
DB_HOST=localhost
DB_USER=postgres
DB_PASS=123456
DB_NAME=gocrud
DB_PORT=5432
```

---

# ğŸ“Œ **3. config/config.go â†’ Load ENV + Connect PostgreSQL**

```go
package config

import (
	"context"
	"fmt"
	"os"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/joho/godotenv"
)

var DB *pgxpool.Pool

func LoadEnv() {
	godotenv.Load()
}

func ConnectDB() {
	url := fmt.Sprintf(
		"postgres://%s:%s@%s:%s/%s",
		os.Getenv("DB_USER"),
		os.Getenv("DB_PASS"),
		os.Getenv("DB_HOST"),
		os.Getenv("DB_PORT"),
		os.Getenv("DB_NAME"),
	)

	pool, err := pgxpool.New(context.Background(), url)
	if err != nil {
		panic(err)
	}

	DB = pool
	fmt.Println("Connected to PostgreSQL!")
}
```

---

# ğŸ“Œ **4. models/user.go**

```go
package models

type User struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}
```

---

# ğŸ“Œ **5. db/migrate.go**

```go
package db

import (
	"context"
	"fmt"
	"go-gin-crud/config"
)

func RunMigrations() {
	q := `
	CREATE TABLE IF NOT EXISTS users (
		id SERIAL PRIMARY KEY,
		name VARCHAR(100),
		email VARCHAR(150)
	)
	`
	_, err := config.DB.Exec(context.Background(), q)
	if err != nil {
		fmt.Println("Migration error:", err)
		return
	}

	fmt.Println("Migration completed!")
}
```

---

# ğŸ“Œ **6. repository/user_repo.go**

```go
package repository

import (
	"context"
	"go-gin-crud/config"
	"go-gin-crud/models"
)

type UserRepository struct{}

func (r *UserRepository) Create(u models.User) error {
	_, err := config.DB.Exec(context.Background(),
		"INSERT INTO users(name, email) VALUES ($1, $2)",
		u.Name, u.Email)
	return err
}

func (r *UserRepository) GetAll() ([]models.User, error) {
	rows, err := config.DB.Query(context.Background(), "SELECT id, name, email FROM users")
	if err != nil {
		return nil, err
	}

	var users []models.User
	for rows.Next() {
		var u models.User
		rows.Scan(&u.ID, &u.Name, &u.Email)
		users = append(users, u)
	}
	return users, nil
}

func (r *UserRepository) GetByID(id int) (models.User, error) {
	var u models.User
	err := config.DB.QueryRow(context.Background(),
		"SELECT id, name, email FROM users WHERE id=$1", id).
		Scan(&u.ID, &u.Name, &u.Email)

	return u, err
}

func (r *UserRepository) Update(id int, u models.User) error {
	_, err := config.DB.Exec(context.Background(),
		"UPDATE users SET name=$1, email=$2 WHERE id=$3",
		u.Name, u.Email, id)
	return err
}

func (r *UserRepository) Delete(id int) error {
	_, err := config.DB.Exec(context.Background(),
		"DELETE FROM users WHERE id=$1", id)
	return err
}
```

---

# ğŸ“Œ **7. service/user_service.go**

```go
package service

import (
	"go-gin-crud/models"
	"go-gin-crud/repository"
)

type UserService struct {
	Repo repository.UserRepository
}

func (s *UserService) Create(u models.User) error {
	return s.Repo.Create(u)
}

func (s *UserService) GetAll() ([]models.User, error) {
	return s.Repo.GetAll()
}

func (s *UserService) GetByID(id int) (models.User, error) {
	return s.Repo.GetByID(id)
}

func (s *UserService) Update(id int, u models.User) error {
	return s.Repo.Update(id, u)
}

func (s *UserService) Delete(id int) error {
	return s.Repo.Delete(id)
}
```

---

# ğŸ“Œ **8. handlers/user_handler.go**

```go
package handlers

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"

	"go-gin-crud/models"
	"go-gin-crud/service"
)

type UserHandler struct {
	Service service.UserService
}

func (h *UserHandler) Create(c *gin.Context) {
	var u models.User
	if err := c.ShouldBindJSON(&u); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON"})
		return
	}

	if err := h.Service.Create(u); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "DB error"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "user created"})
}

func (h *UserHandler) GetAll(c *gin.Context) {
	users, err := h.Service.GetAll()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "DB error"})
		return
	}
	c.JSON(http.StatusOK, users)
}

func (h *UserHandler) GetByID(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	u, err := h.Service.GetByID(id)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "not found"})
		return
	}
	c.JSON(http.StatusOK, u)
}

func (h *UserHandler) Update(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	var u models.User

	if err := c.ShouldBindJSON(&u); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON"})
		return
	}

	if err := h.Service.Update(id, u); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "DB error"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "updated"})
}

func (h *UserHandler) Delete(c *gin.Context) {
	id, _ := strconv.Atoi(c.Param("id"))
	if err := h.Service.Delete(id); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "DB error"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "deleted"})
}
```

---

# ğŸ“Œ **9. cmd/main.go**

```go
package main

import (
	"go-gin-crud/config"
	"go-gin-crud/db"
	"go-gin-crud/handlers"
	"go-gin-crud/repository"
	"go-gin-crud/service"

	"github.com/gin-gonic/gin"
)

func main() {
	config.LoadEnv()
	config.ConnectDB()
	db.RunMigrations()

	repo := repository.UserRepository{}
	serv := service.UserService{Repo: repo}
	handler := handlers.UserHandler{Service: serv}

	r := gin.Default()

	r.POST("/users", handler.Create)
	r.GET("/users", handler.GetAll)
	r.GET("/users/:id", handler.GetByID)
	r.PUT("/users/:id", handler.Update)
	r.DELETE("/users/:id", handler.Delete)

	r.Run(":8080")
}
```

---

# ğŸš€ **Run the API**

```
go mod tidy
go run cmd/main.go
```

---

# ğŸ“Œ **API Test Examples (cURL)**

### **Create**

```
curl -X POST localhost:8080/users \
 -H "Content-Type: application/json" \
 -d '{"name":"Sandeep","email":"sandeep@gmail.com"}'
```

### **Get All**

```
curl localhost:8080/users
```

### **Update**

```
curl -X PUT localhost:8080/users/1 \
 -H "Content-Type: application/json" \
 -d '{"name":"Updated","email":"new@gmail.com"}'
```

---
