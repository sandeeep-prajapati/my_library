Here are **10 high-quality Go concurrency problems** covering **producer–consumer, worker pools, pipeline, fan-in, fan-out, mutex vs channels, rate limiting, fan-out workers, bounded queues, and cancellation** — **each with clean, working solutions**.

All examples are realistic and match patterns used in production Go systems.

---

# ✅ **1. Producer–Consumer (Unbuffered Channel)**

**Problem:**
Create a producer that generates numbers 1–5 and a consumer that prints them. Use an unbuffered channel so sending and receiving must synchronize.

### ✅ **Solution**

```go
package main

import "fmt"

func main() {
    ch := make(chan int)

    go func() { // Producer
        for i := 1; i <= 5; i++ {
            ch <- i
        }
        close(ch)
    }()

    for v := range ch { // Consumer
        fmt.Println("received:", v)
    }
}
```

---

# ✅ **2. Producer–Consumer with Buffered Channel**

**Problem:**
Modify the above so producer can run ahead using a buffer size 2.

### ✅ **Solution**

```go
ch := make(chan int, 2)
```

Everything else stays the same — now producer is not blocked until buffer is full.

---

# ✅ **3. Worker Pool (Fixed 3 Workers)**

**Problem:**
Given jobs 1–10, create 3 workers, each multiplies a number ×2 and returns results.

### ✅ **Solution**

```go
package main

import (
    "fmt"
)

func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        results <- j * 2
    }
}

func main() {
    jobs := make(chan int, 10)
    results := make(chan int, 10)

    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    for j := 1; j <= 10; j++ {
        jobs <- j
    }
    close(jobs)

    for i := 1; i <= 10; i++ {
        fmt.Println(<-results)
    }
}
```

---

# ✅ **4. Fan-Out (Start N Goroutines to Process the Same Input Channel)**

**Problem:**
Start 5 goroutines reading from **one input channel**, each squares numbers.

### ✅ **Solution**

```go
package main

import "fmt"

func squareWorker(id int, in <-chan int, out chan<- int) {
    for n := range in {
        out <- n * n
    }
}

func main() {
    in := make(chan int)
    out := make(chan int)

    for i := 1; i <= 5; i++ {
        go squareWorker(i, in, out)
    }

    go func() {
        for i := 1; i <= 10; i++ {
            in <- i
        }
        close(in)
    }()

    for i := 1; i <= 10; i++ {
        fmt.Println(<-out)
    }
}
```

---

# ✅ **5. Fan-In (Merge Multiple Channels)**

**Problem:**
Merge 2 producer goroutines into a single output channel.

### ✅ **Solution**

```go
package main

import "fmt"

func fanIn(ch1, ch2 <-chan int) <-chan int {
    out := make(chan int)

    go func() {
        defer close(out)
        for ch1 != nil || ch2 != nil {
            select {
            case v, ok := <-ch1:
                if ok {
                    out <- v
                } else {
                    ch1 = nil
                }
            case v, ok := <-ch2:
                if ok {
                    out <- v
                } else {
                    ch2 = nil
                }
            }
        }
    }()
    return out
}

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)

    go func() {
        for i := 1; i <= 5; i++ {
            ch1 <- i
        }
        close(ch1)
    }()
    go func() {
        for i := 10; i <= 15; i++ {
            ch2 <- i
        }
        close(ch2)
    }()

    for v := range fanIn(ch1, ch2) {
        fmt.Println(v)
    }
}
```

---

# ✅ **6. Pipeline (Stage 1 → Stage 2 → Stage 3)**

**Problem:**
Create a 3-stage pipeline:

1. generate numbers
2. square
3. double
   Print final results.

### ✅ **Solution**

```go
func generator(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

func double(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * 2
        }
        close(out)
    }()
    return out
}

func main() {
    c := generator(1, 2, 3, 4)
    out := double(square(c))

    for v := range out {
        fmt.Println(v)
    }
}
```

---

# ✅ **7. Rate Limiter with Ticker (Allow 1 Task per Second)**

**Problem:**
Process 5 tasks but enforce **1 task per second**.

### ✅ **Solution**

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    tasks := []int{1, 2, 3, 4, 5}
    limiter := time.Tick(1 * time.Second)

    for _, t := range tasks {
        <-limiter
        fmt.Println("processing:", t)
    }
}
```

---

# ✅ **8. Mutex vs Channel (Safe Counter)**

**Problem:**
Create a counter safely incremented by 100 goroutines.

### Solution using **channels** (recommended Go style)

```go
package main

import "fmt"

func main() {
    increments := make(chan int)
    done := make(chan bool)

    go func() {
        count := 0
        for inc := range increments {
            count += inc
        }
        fmt.Println("Final:", count)
        done <- true
    }()

    for i := 0; i < 100; i++ {
        go func() { increments <- 1 }()
    }

    time.Sleep(100 * time.Millisecond) // wait for sends
    close(increments)
    <-done
}
```

---

# ✅ **9. Bounded Queue (Drop if Full)**

**Problem:**
Create a buffered channel of size 2. Any extra message should be dropped, not blocked.

### ✅ **Solution**

```go
queue := make(chan int, 2)

for i := 1; i <= 5; i++ {
    select {
    case queue <- i:
        fmt.Println("added:", i)
    default:
        fmt.Println("dropped:", i)
    }
}
```

---

# ✅ **10. Cancellation with Context (Stop Goroutine Early)**

**Problem:**
Run a goroutine that prints numbers continuously. Stop it after 3 seconds using `context.CancelFunc()`.

### ✅ **Solution**

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context) {
    i := 0
    for {
        select {
        case <-ctx.Done():
            fmt.Println("stopped")
            return
        default:
            fmt.Println(i)
            i++
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go worker(ctx)

    time.Sleep(3 * time.Second)
    cancel()

    time.Sleep(time.Second)
}
```

---
