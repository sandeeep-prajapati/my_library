
---

## âœ… Memory in LLVM IR

LLVM IR separates **variables in memory** from **SSA registers**:

* **SSA values** exist in **virtual registers** (immutable, like `%x`).
* **Memory locations** are represented with **pointers** using `alloca`, `load`, and `store`.
* This lets LLVM **model both stack memory and heap memory**.

---

## ðŸ”¹ Key Instructions

| Instruction | Purpose                                                             |
| ----------- | ------------------------------------------------------------------- |
| `alloca`    | Allocate memory on the **stack** for a variable. Returns a pointer. |
| `store`     | Store a value into a memory location (pointer).                     |
| `load`      | Load a value from a memory location into a SSA register.            |

---

## ðŸ”¹ Example 1: Local Variable

C++ code:

```cpp
int x = 10;
x = x + 5;
```

LLVM IR:

```llvm
entry:
  %x = alloca i32        ; allocate memory for x
  store i32 10, i32* %x  ; store 10 into x
  %tmp = load i32, i32* %x   ; load x into SSA value %tmp
  %add = add i32 %tmp, 5     ; add 5
  store i32 %add, i32* %x    ; store result back into memory
```

**Explanation:**

* `%x` â†’ pointer to stack memory
* `store` â†’ write value to memory
* `load` â†’ read value from memory into SSA register `%tmp`
* SSA registers are **immutable**, but memory can be updated with `store`.

---

## ðŸ”¹ Example 2: Array

C++ code:

```cpp
int arr[3] = {1,2,3};
arr[0] = arr[1] + arr[2];
```

LLVM IR (simplified):

```llvm
entry:
  %arr = alloca [3 x i32]         ; allocate array on stack
  %0 = getelementptr [3 x i32], [3 x i32]* %arr, i32 0, i32 0
  store i32 1, i32* %0
  %1 = getelementptr [3 x i32], [3 x i32]* %arr, i32 0, i32 1
  store i32 2, i32* %1
  %2 = getelementptr [3 x i32], [3 x i32]* %arr, i32 0, i32 2
  store i32 3, i32* %2

  %val1 = load i32, i32* %1
  %val2 = load i32, i32* %2
  %sum = add i32 %val1, %val2
  store i32 %sum, i32* %0
```

**Explanation:**

* `alloca [3 x i32]` â†’ allocate array on stack
* `getelementptr` (GEP) â†’ compute pointer to array element
* `load` and `store` â†’ read/write array elements

---

## ðŸ”¹ Key Points

1. `alloca` â†’ stack allocation; lifetime ends when function returns.
2. `store` â†’ write to memory; `load` â†’ read from memory.
3. SSA registers hold **immutable values**, memory is **mutable**.
4. **Arrays, structs, and objects** are all represented using pointers + `load/store`.
5. Memory + SSA separation makes LLVM IR **flexible for optimizations** like **mem2reg**, which promotes stack variables to registers.

---

