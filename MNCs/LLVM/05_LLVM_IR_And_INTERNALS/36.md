
---

## âœ… What is LLVM IR?

**LLVM IR (Intermediate Representation)** is a **low-level, platform-independent assembly language** used by the LLVM compiler infrastructure.

* It is **typed** and **SSA-based** (Static Single Assignment).
* LLVM IR acts as an **intermediate stage** between your high-level code (C/C++, Rust) and machine code.
* Allows **optimizations** and **target-independent analysis** before generating assembly for a specific CPU.

---

### ðŸ”¹ Key Features of LLVM IR

| Feature                            | Description                                              |
| ---------------------------------- | -------------------------------------------------------- |
| **SSA (Static Single Assignment)** | Each variable is assigned exactly once                   |
| **Typed**                          | Every value has a type (`i32`, `float`, `i8*`, etc.)     |
| **Three-address style**            | Instructions usually have a destination and two operands |
| **Platform independent**           | Can be optimized before generating machine code          |

---

## ðŸ§ª Example: Simple `add` Function in C++

```cpp
int add(int a, int b) {
    return a + b;
}
```

### Compile to LLVM IR using `clang`:

```bash
clang -S -emit-llvm add.c -o add.ll
```

### Generated LLVM IR (`add.ll`)

```llvm
; Function add
define i32 @add(i32 %a, i32 %b) {
entry:
  %0 = add i32 %a, %b   ; add a and b
  ret i32 %0            ; return the result
}
```

---

### ðŸ”¹ Explanation

| Line                              | Meaning                                                                  |
| --------------------------------- | ------------------------------------------------------------------------ |
| `define i32 @add(i32 %a, i32 %b)` | Function `add` returns `i32` and takes two `i32` arguments `%a` and `%b` |
| `entry:`                          | Entry **basic block** of the function                                    |
| `%0 = add i32 %a, %b`             | `%0` stores the sum of `%a` and `%b`                                     |
| `ret i32 %0`                      | Return the value `%0`                                                    |

---

### ðŸ”¹ Key Points

* LLVM IR is **human-readable** and **typed**.
* `%` indicates a **register/value** in SSA form.
* Each instruction produces a **new SSA value** rather than modifying existing ones.
* Can be **optimized** using LLVM passes before generating machine code.

---

### ðŸ’¡ Challenge:

* Write a C function that **multiplies two integers** and see the corresponding LLVM IR.
* Observe how SSA form and typed instructions are used for multiplication.

---

