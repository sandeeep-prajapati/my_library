
---

## âœ… Overview

`clang` can generate **LLVM Intermediate Representation (IR)** from C (or C++) code.

* **LLVM IR** is a **platform-independent, typed, SSA-based assembly language**.
* You can use it to **inspect, analyze, and optimize code** before generating machine code.

---

## ðŸ”¹ Command

```bash
clang -S -emit-llvm source.c -o output.ll
```

### Explanation of Flags:

| Flag           | Meaning                                                    |
| -------------- | ---------------------------------------------------------- |
| `-S`           | Generate **assembly-level output** (not a compiled binary) |
| `-emit-llvm`   | Generate **LLVM IR** instead of target machine assembly    |
| `source.c`     | Your input C source file                                   |
| `-o output.ll` | Name of the output LLVM IR file                            |

---

## ðŸ”¹ Example

**C code (`add.c`):**

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 5);
    return 0;
}
```

**Command to generate LLVM IR:**

```bash
clang -S -emit-llvm add.c -o add.ll
```

**Generated LLVM IR (`add.ll`):**

```llvm
; Function add
define i32 @add(i32 %a, i32 %b) {
entry:
  %0 = add i32 %a, %b
  ret i32 %0
}

; Function main
define i32 @main() {
entry:
  %call = call i32 @add(i32 3, i32 5)
  ret i32 0
}
```

---

### ðŸ”¹ Key Points

* `%a`, `%b` are SSA **registers representing arguments**.
* `add i32 %a, %b` performs integer addition.
* IR is **human-readable** and **platform-independent**.
* You can **run optimizations** on `.ll` using `opt` or convert it to machine code using `llc`.

---

### ðŸ”¹ Next Steps / Practice

* Compile a C program with a **loop** and see how loops are represented in LLVM IR.
* Experiment with **`opt -O1` or `-O2`** to see optimized IR.

---
