
---

## âœ… C Code: Simple `for` Loop

```c
#include <stdio.h>

int main() {
    int sum = 0;
    for (int i = 1; i <= 5; i++) {
        sum += i;
    }
    return sum;
}
```

---

## ðŸ”¹ Generate LLVM IR

```bash
clang -S -emit-llvm for_loop.c -o for_loop.ll
```

This produces a human-readable LLVM IR file (`for_loop.ll`).

---

## ðŸ”¹ Sample LLVM IR Output

```llvm
define i32 @main() {
entry:
  %sum = alloca i32, align 4
  store i32 0, i32* %sum, align 4
  %i = alloca i32, align 4
  store i32 1, i32* %i, align 4
  br label %loop

loop:
  %i_val = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %i_val, 5
  br i1 %cmp, label %body, label %end

body:
  %i_val2 = load i32, i32* %i, align 4
  %sum_val = load i32, i32* %sum, align 4
  %add = add i32 %sum_val, %i_val2
  store i32 %add, i32* %sum, align 4
  %i_val3 = load i32, i32* %i, align 4
  %inc = add i32 %i_val3, 1
  store i32 %inc, i32* %i, align 4
  br label %loop

end:
  %sum_val2 = load i32, i32* %sum, align 4
  ret i32 %sum_val2
}
```

---

## ðŸ”¹ IR Breakdown

| IR Part                               | Meaning                                              |
| ------------------------------------- | ---------------------------------------------------- |
| `alloca i32, align 4`                 | Allocate stack memory for a variable (`sum` and `i`) |
| `store i32 0, i32* %sum`              | Initialize `sum = 0`                                 |
| `br label %loop`                      | Unconditional branch to `loop` block                 |
| `%i_val = load i32, i32* %i`          | Load current value of `i`                            |
| `%cmp = icmp sle i32 %i_val, 5`       | Compare `i <= 5`                                     |
| `br i1 %cmp, label %body, label %end` | Conditional branch based on comparison               |
| `%add = add i32 %sum_val, %i_val2`    | Compute `sum += i`                                   |
| `%inc = add i32 %i_val3, 1`           | Increment `i` by 1                                   |
| `ret i32 %sum_val2`                   | Return the final `sum`                               |

---

### ðŸ”¹ Key Observations

1. **SSA form**:

   * Every value assigned **once** (e.g., `%add`, `%inc`).
2. **Basic blocks**:

   * `entry`, `loop`, `body`, `end` separate control flow.
3. **Branches**:

   * Conditional (`br i1 %cmp`) and unconditional (`br label %loop`).
4. **Memory operations**:

   * `alloca` â†’ stack allocation, `load`/`store` â†’ read/write from memory.

---

### ðŸ”¹ What You Learn from This

* How **loops are translated** into IR with **basic blocks**.
* How LLVM IR uses **SSA values** for every computation.
* How **control flow** is explicit in IR (`br` instructions).

---

