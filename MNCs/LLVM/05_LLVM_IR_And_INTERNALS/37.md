
---

## ‚úÖ The Three Forms of LLVM IR

LLVM IR is **not just one single representation**‚Äîit evolves through **three levels of abstraction**:

| Form                    | Description                                                                                                                                                      | Example Use                                                                                 |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| **High-Level IR (HIR)** | Closest to the original source code. Keeps higher-level structures like arrays, structs, function calls. Easier to perform source-level optimizations.           | Optimizations like **loop unrolling**, **inlining**, **constant propagation**.              |
| **Mid-Level IR (MIR)**  | Simplified, normalized version. Uses **SSA form**, explicit types, simple control flow. Most **LLVM optimizations** are applied at this level.                   | **Instruction combining**, **dead code elimination**, **common subexpression elimination**. |
| **Low-Level IR (LIR)**  | Closest to machine code. Introduces **explicit memory operations**, stack allocation (`alloca`), and target-specific instructions. Prepares for code generation. | Target-specific optimizations like **register allocation** and **instruction selection**.   |

---

### üîπ Example: C Function

C code:

```c
int add(int a, int b) {
    return a + b;
}
```

---

### 1Ô∏è‚É£ High-Level IR (HIR)

* Retains higher-level constructs.
* Might represent addition as a **function call to `llvm.add` intrinsic**.

```llvm
define i32 @add(i32 %a, i32 %b) {
entry:
  %sum = add i32 %a, %b
  ret i32 %sum
}
```

> Looks almost like the original source, but typed and in SSA form.

---

### 2Ô∏è‚É£ Mid-Level IR (MIR)

* SSA form is fully applied.
* Control flow and instructions are simplified for optimization.

```llvm
%0 = add i32 %a, %b
ret i32 %0
```

> Ready for most LLVM optimizations.

---

### 3Ô∏è‚É£ Low-Level IR (LIR)

* Explicit memory allocation (`alloca`) and load/store instructions.
* Prepares IR for machine code generation.

```llvm
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  store i32 %a, i32* %a.addr
  store i32 %b, i32* %b.addr
  %0 = load i32, i32* %a.addr
  %1 = load i32, i32* %b.addr
  %sum = add i32 %0, %1
  ret i32 %sum
```

---

### üîπ Summary

| Feature               | HIR          | MIR             | LIR                      |
| --------------------- | ------------ | --------------- | ------------------------ |
| Abstraction level     | High         | Medium          | Low                      |
| Resembles source code | ‚úÖ            | ‚ùå               | ‚ùå                        |
| Optimizations         | Source-level | LLVM-level      | Target-specific          |
| SSA form              | Partial      | ‚úÖ               | ‚úÖ                        |
| Memory operations     | Implicit     | Mostly implicit | Explicit (`alloca/load`) |

---

### üí° Key Takeaways

* **HIR** ‚Üí High-level, easier to read, close to source.
* **MIR** ‚Üí Optimizations happen here, SSA-based.
* **LIR** ‚Üí Prepares for **machine code**, handles memory explicitly.

---

