Hereâ€™s a clear explanation of **LLVM Passes** and how they work:

---

## âœ… What is an LLVM Pass?

An **LLVM Pass** is a **module of code that analyzes or transforms LLVM IR**.

* LLVM passes operate on the **intermediate representation (IR)**, allowing **optimizations, analysis, or transformations** before generating machine code.
* They are the **core mechanism** for LLVM optimizations and custom analyses.
* Passes can be **analysis passes** (read-only) or **transformation passes** (modify IR).

---

### ðŸ”¹ Types of LLVM Passes

| Type               | Description                                                            |
| ------------------ | ---------------------------------------------------------------------- |
| **FunctionPass**   | Operates on a **single function** at a time                            |
| **ModulePass**     | Operates on the **entire module** (all functions, globals)             |
| **LoopPass**       | Operates on **loops** inside functions                                 |
| **BasicBlockPass** | Operates on **basic blocks** inside functions                          |
| **AnalysisPass**   | Collects information (e.g., CFG, dominators) but **doesnâ€™t modify IR** |

---

### ðŸ”¹ Why Use LLVM Passes?

* Optimize code (e.g., remove dead code, constant propagation, inlining)
* Collect metrics/statistics (e.g., number of instructions, loops)
* Transform IR for custom needs (e.g., insert logging, instrumentation)
* Build **custom static analysis tools**

---

### ðŸ”¹ Example: Simple FunctionPass (Count Instructions)

```cpp
#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

namespace {
struct CountInstPass : public FunctionPass {
  static char ID;
  CountInstPass() : FunctionPass(ID) {}

  bool runOnFunction(Function &F) override {
    int count = 0;
    for (auto &BB : F) {
      for (auto &I : BB) {
        count++;
      }
    }
    errs() << "Function " << F.getName() << " has " << count << " instructions.\n";
    return false; // We didnâ€™t modify IR
  }
};
}

char CountInstPass::ID = 0;
static RegisterPass<CountInstPass> X("countinst", "Count Instructions Pass", false, false);
```

---

### ðŸ”¹ How It Works

1. **Register the pass** with LLVM using `RegisterPass`.
2. LLVM calls `runOnFunction` for **each function** in the module.
3. You can **analyze or modify IR** inside the pass.
4. Return `true` if you **modified IR**, `false` if only analyzing.

---

### ðŸ”¹ Running the Pass

Assuming your pass is compiled as a shared library:

```bash
opt -load ./CountInstPass.so -countinst < input.bc > /dev/null
```

* `opt` â†’ LLVM tool to **run passes on IR**
* `-countinst` â†’ Our pass that counts instructions

---

### ðŸ”¹ Key Takeaways

* LLVM passes operate **on IR**, not source code.
* Can be **analysis** or **transformation** passes.
* Central to **LLVMâ€™s optimization and analysis framework**.

---
