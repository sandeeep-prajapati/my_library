
---

## âœ… What is Control Flow in LLVM IR?

Control flow in LLVM IR represents **the order in which instructions are executed**.

* LLVM IR is **in Static Single Assignment (SSA) form**, so values are immutable.
* **Basic blocks** and **branch instructions** define the flow of execution.
* Each **function** is composed of **basic blocks**, which end with a **terminator instruction** that determines the next block.

---

## ðŸ”¹ Key Concepts

| Concept           | Description                                                                         |
| ----------------- | ----------------------------------------------------------------------------------- |
| **Basic Block**   | A sequence of instructions with **one entry and one exit point**.                   |
| **Terminator**    | Instruction that ends a basic block, e.g., `br` (branch), `ret` (return), `switch`. |
| **Branch (`br`)** | Transfers control **conditionally** or **unconditionally**.                         |
| **Labels**        | Named basic blocks used as branch targets.                                          |
| **PHI nodes**     | Resolve variable values coming from **multiple predecessor blocks**.                |

---

## ðŸ”¹ Example 1: Simple `if-else`

C++ code:

```cpp
int max(int a, int b) {
    if (a > b)
        return a;
    else
        return b;
}
```

LLVM IR (simplified):

```llvm
define i32 @max(i32 %a, i32 %b) {
entry:
  %cmp = icmp sgt i32 %a, %b
  br i1 %cmp, label %if_true, label %if_false

if_true:
  ret i32 %a

if_false:
  ret i32 %b
}
```

**Explanation:**

* `%cmp = icmp sgt i32 %a, %b` â†’ Compare `a > b`.
* `br i1 %cmp, label %if_true, label %if_false` â†’ Conditional branch based on comparison.
* `if_true` and `if_false` â†’ Basic blocks that return the correct value.

---

## ðŸ”¹ Example 2: Simple `for` Loop

C++ code:

```cpp
int sum = 0;
for (int i = 1; i <= 5; i++) {
    sum += i;
}
```

LLVM IR (simplified):

```llvm
entry:
  %sum = alloca i32
  store i32 0, i32* %sum
  %i = alloca i32
  store i32 1, i32* %i
  br label %loop

loop:
  %i_val = load i32, i32* %i
  %cmp = icmp sle i32 %i_val, 5
  br i1 %cmp, label %body, label %end

body:
  %sum_val = load i32, i32* %sum
  %sum_new = add i32 %sum_val, %i_val
  store i32 %sum_new, i32* %sum
  %i_next = add i32 %i_val, 1
  store i32 %i_next, i32* %i
  br label %loop

end:
  ret i32 %sum
```

**Explanation:**

* **`entry`** â†’ Initializes variables.
* **`loop`** â†’ Checks loop condition (`i <= 5`).
* **`body`** â†’ Updates sum and increments `i`.
* **`br` instructions** â†’ Control flow between blocks.
* **`end`** â†’ Loop exit, returns result.

---

## ðŸ”¹ Key Points

1. **Each basic block ends with a terminator** (`ret`, `br`, `switch`).
2. **Conditional branches** use `br i1 <cond>, label <true>, label <false>`.
3. **Loops** are implemented using **conditional branches back to loop blocks**.
4. **PHI nodes** are used when a variable has **different values coming from multiple blocks**.
5. **LLVM IR control flow** is explicit, unlike C++ where itâ€™s implicit in code structure.

---

