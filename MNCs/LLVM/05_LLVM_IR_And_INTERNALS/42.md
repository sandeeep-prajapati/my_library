Sure! Letâ€™s create a **simple LLVM FunctionPass** that counts the number of instructions in each function. This is a **classic first pass** for learning LLVM pass development.

---

## âœ… Step 1: Pass Code (`CountInstPass.cpp`)

```cpp
#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

namespace {

struct CountInstPass : public FunctionPass {
  static char ID;
  CountInstPass() : FunctionPass(ID) {}

  // This method is called for each function in the module
  bool runOnFunction(Function &F) override {
    int instCount = 0;

    // Iterate over all basic blocks in the function
    for (auto &BB : F) {
      // Iterate over all instructions in the basic block
      for (auto &I : BB) {
        instCount++;
      }
    }

    // Print function name and instruction count
    errs() << "Function " << F.getName() << " has " << instCount << " instructions.\n";

    // Return false because we do NOT modify the IR
    return false;
  }
};

} // namespace

char CountInstPass::ID = 0;

// Register the pass with LLVM, giving it a name and description
static RegisterPass<CountInstPass> X("countinst", "Instruction Count Pass", false, false);
```

---

## âœ… Step 2: Compile the Pass

Assuming you have **LLVM installed** and `llvm-config` in your PATH:

```bash
clang++ -fno-rtti -shared -fPIC CountInstPass.cpp \
    `llvm-config --cxxflags --ldflags --system-libs --libs core` \
    -o CountInstPass.so
```

* `-fno-rtti` â†’ LLVM doesnâ€™t use RTTI
* `-shared -fPIC` â†’ Build a shared library for `opt`

---

## âœ… Step 3: Run the Pass on LLVM IR

First, compile your C/C++ code to LLVM IR:

```bash
clang -O0 -emit-llvm -c test.c -o test.bc
```

Run your pass with `opt`:

```bash
opt -load ./CountInstPass.so -countinst < test.bc > /dev/null
```

**Output Example:**

```
Function main has 12 instructions.
Function add has 3 instructions.
```

---

## ðŸ”¹ How It Works

1. `runOnFunction` is called for **each function** in the module.
2. Loops over **basic blocks** â†’ **instructions**.
3. Counts instructions and prints via `errs()`.
4. Returns `false` because the IR **is not modified**.

---

### ðŸ”¹ Key Notes

* `errs()` prints to **stderr**, commonly used in LLVM for debug messages.
* To create a **transformation pass**, you would **modify instructions** and return `true`.
* This is a **FunctionPass**, but LLVM also supports `ModulePass`, `LoopPass`, etc.

---
