Awesome, Sandeep! Let's upgrade the **toy Kaleidoscope language** to support:

> ‚úÖ **`if-else` expressions**
> ‚úÖ **`while` loops**

This will teach you how to **generate control flow** (branching and looping) using LLVM IR in C++.

---

## üîÅ Target Syntax Examples

We'll support constructs like:

```c++
if x < y then x else y
```

```c++
while x < 10 do
  x = x + 1
```

---

## ‚úÖ Step 1: Add `IfExprAST` and `WhileExprAST`

Modify your AST class hierarchy in `main.cpp`.

---

### üìò `IfExprAST`

```cpp
class IfExprAST : public ExprAST {
  std::unique_ptr<ExprAST> Cond, Then, Else;

public:
  IfExprAST(std::unique_ptr<ExprAST> Cond,
            std::unique_ptr<ExprAST> Then,
            std::unique_ptr<ExprAST> Else)
      : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {}

  Value *codegen() override {
    Value *CondV = Cond->codegen();
    if (!CondV) return nullptr;

    CondV = Builder.CreateFCmpONE(
        CondV, ConstantFP::get(TheContext, APFloat(0.0)), "ifcond");

    Function *TheFunction = Builder.GetInsertBlock()->getParent();

    BasicBlock *ThenBB = BasicBlock::Create(TheContext, "then", TheFunction);
    BasicBlock *ElseBB = BasicBlock::Create(TheContext, "else");
    BasicBlock *MergeBB = BasicBlock::Create(TheContext, "ifcont");

    Builder.CreateCondBr(CondV, ThenBB, ElseBB);

    Builder.SetInsertPoint(ThenBB);
    Value *ThenV = Then->codegen();
    if (!ThenV) return nullptr;
    Builder.CreateBr(MergeBB);

    ThenBB = Builder.GetInsertBlock();

    TheFunction->getBasicBlockList().push_back(ElseBB);
    Builder.SetInsertPoint(ElseBB);
    Value *ElseV = Else->codegen();
    if (!ElseV) return nullptr;
    Builder.CreateBr(MergeBB);

    ElseBB = Builder.GetInsertBlock();

    TheFunction->getBasicBlockList().push_back(MergeBB);
    Builder.SetInsertPoint(MergeBB);

    PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, "iftmp");
    PN->addIncoming(ThenV, ThenBB);
    PN->addIncoming(ElseV, ElseBB);
    return PN;
  }
};
```

---

### üîÅ `WhileExprAST`

```cpp
class WhileExprAST : public ExprAST {
  std::unique_ptr<ExprAST> Cond, Body;

public:
  WhileExprAST(std::unique_ptr<ExprAST> Cond,
               std::unique_ptr<ExprAST> Body)
      : Cond(std::move(Cond)), Body(std::move(Body)) {}

  Value *codegen() override {
    Function *TheFunction = Builder.GetInsertBlock()->getParent();

    BasicBlock *CondBB = BasicBlock::Create(TheContext, "whilecond", TheFunction);
    BasicBlock *LoopBB = BasicBlock::Create(TheContext, "whilebody");
    BasicBlock *AfterBB = BasicBlock::Create(TheContext, "afterwhile");

    Builder.CreateBr(CondBB);
    Builder.SetInsertPoint(CondBB);

    Value *CondV = Cond->codegen();
    if (!CondV) return nullptr;
    CondV = Builder.CreateFCmpONE(CondV,
        ConstantFP::get(TheContext, APFloat(0.0)), "whilecond");

    Builder.CreateCondBr(CondV, LoopBB, AfterBB);

    TheFunction->getBasicBlockList().push_back(LoopBB);
    Builder.SetInsertPoint(LoopBB);
    if (!Body->codegen()) return nullptr;
    Builder.CreateBr(CondBB);

    TheFunction->getBasicBlockList().push_back(AfterBB);
    Builder.SetInsertPoint(AfterBB);

    return Constant::getNullValue(Type::getDoubleTy(TheContext));
  }
};
```

---

## ‚úÖ Step 2: Usage Example in Code (Mock)

You can **manually construct** `IfExprAST` and `WhileExprAST` nodes for now:

```cpp
int main() {
  TheModule = make_unique<Module>("if-while-example", TheContext);

  // Build: if (a < b) then a else b
  auto Cond = std::make_unique<BinaryExprAST>('<',
      std::make_unique<VariableExprAST>("a"),
      std::make_unique<VariableExprAST>("b"));

  auto Then = std::make_unique<VariableExprAST>("a");
  auto Else = std::make_unique<VariableExprAST>("b");

  auto IfExpr = std::make_unique<IfExprAST>(
      std::move(Cond), std::move(Then), std::move(Else));

  auto Proto = std::make_unique<PrototypeAST>("min", std::vector<std::string>{"a", "b"});
  auto Func = std::make_unique<FunctionAST>(std::move(Proto), std::move(IfExpr));
  Func->codegen();

  TheModule->print(outs(), nullptr);
}
```

---

## ‚úÖ Output LLVM IR (if-else)

```llvm
define double @min(double %a, double %b) {
entry:
  %cmptmp = fcmp ult double %a, %b
  br i1 %cmptmp, label %then, label %else

then:
  br label %ifcont

else:
  br label %ifcont

ifcont:
  %iftmp = phi double [ %a, %then ], [ %b, %else ]
  ret double %iftmp
}
```

---

## üß† Summary

| Feature        | Implemented                                       |
| -------------- | ------------------------------------------------- |
| `IfExprAST`    | ‚úÖ Yes ‚Äì with `phi` nodes                          |
| `WhileExprAST` | ‚úÖ Yes ‚Äì with looping control                      |
| Control flow   | Fully working with LLVM IR                        |
| Next Step      | Add parsing support for `if` and `while` keywords |

---

