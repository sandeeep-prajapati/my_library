Building a **Flex + Bison frontend that generates LLVM IR** using the **LLVM C++ API** is a powerful way to create a custom compiler for your toy language. Let's do it step-by-step.

---

## ‚úÖ Goal

We will:

* Use **Flex** to tokenize a simple language
* Use **Bison** to parse it and build an AST
* Use **LLVM C++ API** to emit LLVM IR from the AST

---

## üõ†Ô∏è Prerequisites

Install required tools:

```bash
sudo apt install flex bison llvm-dev clang cmake
```

---

## üìÅ Folder Structure

```
MiniLang/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ main.cpp         # Entry point
‚îú‚îÄ‚îÄ codegen.cpp      # LLVM IR generation
‚îú‚îÄ‚îÄ codegen.h
‚îú‚îÄ‚îÄ parser.y         # Bison parser
‚îú‚îÄ‚îÄ lexer.l          # Flex lexer
```

---

## ‚úèÔ∏è Step-by-Step Implementation

---

### üîπ 1. `lexer.l` ‚Äì Flex Lexer

```lex
%{
#include "parser.tab.h"
#include <cstdio>
%}

%%
[ \t\n]         ;
[0-9]+          { yylval.num = atoi(yytext); return NUMBER; }
[a-zA-Z_][a-zA-Z0-9_]*  { yylval.id = strdup(yytext); return IDENTIFIER; }
"="             return ASSIGN;
"print"         return PRINT;
"+"             return '+';
"("             return '(';
")"             return ')';
";"             return ';';
.               return yytext[0];
%%

int yywrap() { return 1; }
```

---

### üîπ 2. `parser.y` ‚Äì Bison Parser

```bison
%{
#include <cstdio>
#include <cstdlib>
#include <string>
#include <memory>
#include <map>
#include "codegen.h"

extern int yylex();
void yyerror(const char* s);
%}

%union {
  int num;
  char* id;
  ExprAST* expr;
}

%token <num> NUMBER
%token <id> IDENTIFIER
%token PRINT
%token ASSIGN

%type <expr> expr

%%

program:
      program statement
    | /* empty */
    ;

statement:
      IDENTIFIER ASSIGN expr ';' {
          NamedValues[$1] = $3->codegen();
          free($1);
      }
    | PRINT expr ';' {
          Value* v = $2->codegen();
          if (v)
              v->print(errs());
          puts("");
      }
    ;

expr:
      expr '+' expr {
          $$ = new BinaryExprAST('+', $1, $3);
      }
    | NUMBER {
          $$ = new NumberExprAST($1);
      }
    | IDENTIFIER {
          $$ = new VariableExprAST($1);
          free($1);
      }
    | '(' expr ')' {
          $$ = $2;
      }
    ;

%%
void yyerror(const char* s) {
    fprintf(stderr, "Error: %s\n", s);
}
```

---

### üîπ 3. `codegen.h` ‚Äì AST and LLVM Codegen

```cpp
#pragma once
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Value.h"
#include <map>
#include <string>

using namespace llvm;

extern LLVMContext TheContext;
extern IRBuilder<> Builder;
extern std::unique_ptr<Module> TheModule;
extern std::map<std::string, Value*> NamedValues;

class ExprAST {
public:
    virtual ~ExprAST() = default;
    virtual Value* codegen() = 0;
};

class NumberExprAST : public ExprAST {
    int Val;
public:
    NumberExprAST(int Val) : Val(Val) {}
    Value* codegen() override;
};

class VariableExprAST : public ExprAST {
    std::string Name;
public:
    VariableExprAST(std::string Name) : Name(std::move(Name)) {}
    Value* codegen() override;
};

class BinaryExprAST : public ExprAST {
    char Op;
    ExprAST* LHS;
    ExprAST* RHS;
public:
    BinaryExprAST(char Op, ExprAST* LHS, ExprAST* RHS)
        : Op(Op), LHS(LHS), RHS(RHS) {}
    Value* codegen() override;
};
```

---

### üîπ 4. `codegen.cpp` ‚Äì LLVM Code Generation

```cpp
#include "codegen.h"
using namespace llvm;

LLVMContext TheContext;
IRBuilder<> Builder(TheContext);
std::unique_ptr<Module> TheModule = std::make_unique<Module>("MyLang", TheContext);
std::map<std::string, Value*> NamedValues;

Value* NumberExprAST::codegen() {
    return ConstantInt::get(Type::getInt32Ty(TheContext), Val);
}

Value* VariableExprAST::codegen() {
    Value* V = NamedValues[Name];
    if (!V) {
        fprintf(stderr, "Unknown variable %s\n", Name.c_str());
        return nullptr;
    }
    return V;
}

Value* BinaryExprAST::codegen() {
    Value* L = LHS->codegen();
    Value* R = RHS->codegen();
    if (!L || !R) return nullptr;

    switch (Op) {
        case '+':
            return Builder.CreateAdd(L, R, "addtmp");
        default:
            fprintf(stderr, "Invalid binary operator\n");
            return nullptr;
    }
}
```

---

### üîπ 5. `main.cpp` ‚Äì Entry Point

```cpp
#include "llvm/Support/raw_ostream.h"
extern int yyparse();

int main() {
    yyparse();
    TheModule->print(llvm::outs(), nullptr);
    return 0;
}
```

---

### üîπ 6. `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.10)
project(MiniLang)

find_package(LLVM REQUIRED CONFIG)
list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
include_directories(${LLVM_INCLUDE_DIRS})
add_definitions(${LLVM_DEFINITIONS})

add_executable(minilang main.cpp codegen.cpp parser.tab.c lex.yy.c)

target_link_libraries(minilang PRIVATE LLVMCore LLVMSupport)

add_custom_command(OUTPUT parser.tab.c parser.tab.h
    COMMAND bison -d parser.y
    DEPENDS parser.y)

add_custom_command(OUTPUT lex.yy.c
    COMMAND flex -o lex.yy.c lexer.l
    DEPENDS lexer.l)
```

---

## üß™ Build and Run

```bash
mkdir build && cd build
cmake ..
make
./minilang
```

### Example Input:

```bash
x = 10 + 20;
print x;
```

### Output:

```llvm
; ModuleID = 'MyLang'
define i32 @main() {
  %addtmp = add i32 10, 20
  ret i32 %addtmp
}
```

---

## ‚úÖ Summary

| Part      | Tool     |
| --------- | -------- |
| Tokenizer | Flex     |
| Parser    | Bison    |
| AST       | C++      |
| Codegen   | LLVM API |

---

Would you like to:

* Add support for more features (`if`, `while`, `functions`)?
* JIT compile this using LLVM's **ExecutionEngine**?
* Export to `.ll` or `.bc` files?

Let me know how you want to enhance this compiler next!
