Absolutely, Sandeep! `target_link_libraries` is a key CMake command used to **link libraries to your targets** (executables or libraries). Letâ€™s break it down clearly.

---

## âœ… What is `target_link_libraries`?

* It tells CMake **which libraries your executable or library depends on**.
* Ensures **correct linking** at compile time.
* Can link **system libraries**, **third-party libraries**, or **other CMake targets**.

---

## ðŸ”¹ Syntax

```cmake
target_link_libraries(<target> [PRIVATE|PUBLIC|INTERFACE] <libraries...>)
```

* `<target>` â†’ your executable or library.
* `<libraries...>` â†’ libraries to link.
* **Linkage keywords**:

| Keyword   | Meaning                                                      |
| --------- | ------------------------------------------------------------ |
| PRIVATE   | Library used **only for this target**                        |
| PUBLIC    | Library used for this target **and propagate to dependents** |
| INTERFACE | Library **only for dependents**, not for this target         |

---

## ðŸ”¹ Example 1: Linking a System Library

Suppose we have `main.cpp` using the math library `-lm`.

### `main.cpp`

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    double result = sqrt(16.0);
    cout << "Square root of 16 = " << result << endl;
    return 0;
}
```

### `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.10)
project(MathExample LANGUAGES CXX)

add_executable(MathExample main.cpp)

# Link math library (system)
target_link_libraries(MathExample PRIVATE m)
```

**Build and Run:**

```bash
mkdir build
cd build
cmake ..
make
./MathExample
```

**Output:**

```
Square root of 16 = 4
```

---

## ðŸ”¹ Example 2: Linking Another CMake Target

Suppose you have **two libraries**: `libmath` and an executable using it.

```
MyProject/
 â”œâ”€â”€ CMakeLists.txt
 â”œâ”€â”€ mathlib/
 â”‚    â”œâ”€â”€ CMakeLists.txt
 â”‚    â””â”€â”€ math.cpp
 â””â”€â”€ main.cpp
```

### `math.cpp`

```cpp
#include <iostream>
void printHello() {
    std::cout << "Hello from mathlib!\n";
}
```

### `mathlib/CMakeLists.txt`

```cmake
add_library(mathlib STATIC math.cpp)
```

### `CMakeLists.txt` (Top-level)

```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject LANGUAGES CXX)

add_subdirectory(mathlib)

add_executable(MainExec main.cpp)

# Link library
target_link_libraries(MainExec PRIVATE mathlib)
```

### `main.cpp`

```cpp
void printHello();

int main() {
    printHello();
    return 0;
}
```

**Output:**

```
Hello from mathlib!
```

---

## ðŸ”¹ Key Points

1. **Link Order Matters:** Libraries should be listed **after the target**.
2. **PRIVATE vs PUBLIC vs INTERFACE:** Controls propagation to other targets.
3. Can link **system libraries** (`m`, `pthread`) or **CMake-built libraries** (`mathlib`).
4. Works for **STATIC, SHARED, and INTERFACE libraries**.

---

If you want, I can create a **diagram showing `target_link_libraries` linking an executable to multiple static/shared libraries** with PRIVATE/PUBLIC/INTERFACE propagation â€” very helpful for large projects like LLVM.

Do you want me to make that diagram?
