Great question, Sandeep! Move semantics is one of the **most powerful and performance-improving features** introduced in **C++11**.

Let‚Äôs understand it step by step.

---

## ‚úÖ What is Move Semantics?

**Move semantics** allows the resources of a temporary or expendable object to be **transferred**, not copied.

### üß† Why?

To avoid **costly deep copies** of objects, especially those that manage dynamic memory (like `std::vector`, `std::string`, etc.).

---

## üîÅ Copy vs Move Semantics

### üü• Copy (Before C++11):

```cpp
std::string a = "Hello";
std::string b = a;  // deep copy (allocates memory, copies data)
```

### üü© Move (C++11 and after):

```cpp
std::string a = "Hello";
std::string b = std::move(a); // b takes ownership, a is now empty
```

* No deep copy is done.
* Just **steals the pointer** from `a` ‚Üí **faster!**

---

## üõ† How It Works Internally

### üëá You define:

1. A **move constructor**:

```cpp
ClassName(ClassName&& other);
```

2. A **move assignment operator**:

```cpp
ClassName& operator=(ClassName&& other);
```

> Both take **rvalue references** (`&&`) ‚Äî objects that can be moved.

---

## üîß Example: Move Constructor in a Custom Class

```cpp
#include <iostream>
#include <string>

class MyString {
    char* data;
public:
    // Constructor
    MyString(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // Destructor
    ~MyString() {
        delete[] data;
    }

    // Move Constructor
    MyString(MyString&& other) {
        data = other.data;
        other.data = nullptr;  // Nullify source
    }

    void show() {
        std::cout << (data ? data : "null") << "\n";
    }
};
```

### ‚úÖ Usage:

```cpp
int main() {
    MyString a("Hello");
    MyString b = std::move(a);  // Calls move constructor

    a.show(); // null
    b.show(); // Hello

    return 0;
}
```

---

## üì¶ STL and Move Semantics

C++11 STL containers like `std::vector`, `std::map`, etc. **automatically use move semantics** when:

* Reallocating
* Returning large objects
* Inserting temporary objects

Example:

```cpp
std::vector<std::string> v;
v.push_back(std::move(some_big_string)); // moves instead of copying
```

---

## üß™ std::move

* `std::move()` **does not actually move** anything.
* It **casts an lvalue to an rvalue**, making it eligible for move operations.

Example:

```cpp
std::string a = "Hello";
std::string b = std::move(a); // Enables move constructor
```

> After this, `a` is in a **valid but unspecified state** (often empty).

---

## üß† Rule of 5 (Important in Move Semantics)

If you define **any** of these manually:

1. Destructor
2. Copy constructor
3. Copy assignment
4. Move constructor
5. Move assignment

You should consider defining **all five**, to maintain proper ownership and avoid memory issues.

---

## üîç Benefits of Move Semantics

| Benefit          | Description                               |
| ---------------- | ----------------------------------------- |
| ‚ö° Faster         | Avoids unnecessary deep copies            |
| ‚úÖ Safe           | Ensures ownership is transferred properly |
| ‚ôªÔ∏è Efficient     | Perfect for return by value               |
| üß† STL optimized | All containers use it internally          |

---

## ‚úÖ Summary

| Feature         | Copy Semantics    | Move Semantics                     |
| --------------- | ----------------- | ---------------------------------- |
| Purpose         | Duplicate object  | Transfer ownership                 |
| Overhead        | High (deep copy)  | Low (pointer swap)                 |
| Syntax          | `T(const T&)`     | `T(T&&)`                           |
| Enabled with    | Nothing (default) | `std::move()`                      |
| State of source | Unchanged         | Valid but unspecified (e.g., null) |

---
