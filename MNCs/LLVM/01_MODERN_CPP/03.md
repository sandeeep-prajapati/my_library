
---

## ✅ What Are Smart Pointers?

**Smart pointers** are **wrapper classes** in C++ that **automatically manage memory** — they ensure that dynamically allocated objects are properly destroyed when they are no longer needed.

> 🔥 Think of them as **"auto-deleting pointers"** that follow **RAII** principles.

---

## 🧠 Why Use Smart Pointers?

Traditional raw pointers (`int* p = new int`) require manual `delete`. If you forget to delete or delete too early, it can cause:

* **Memory leaks**
* **Dangling pointers**
* **Double deletes**

Smart pointers prevent these problems.

---

## 🧰 Types of Smart Pointers in C++11 and Later

| Smart Pointer        | Ownership Model                    | Use Case                     |
| -------------------- | ---------------------------------- | ---------------------------- |
| `std::unique_ptr<T>` | Sole owner, non-copyable           | Exclusive resource ownership |
| `std::shared_ptr<T>` | Shared ownership (ref-counted)     | Shared use of a resource     |
| `std::weak_ptr<T>`   | Non-owning reference to shared_ptr | Break circular references    |

---

## 🔸 `std::unique_ptr` Example

```cpp
#include <iostream>
#include <memory>

class Demo {
public:
    Demo()  { std::cout << "Demo created\n"; }
    ~Demo() { std::cout << "Demo destroyed\n"; }
    void greet() { std::cout << "Hello from unique_ptr\n"; }
};

int main() {
    std::unique_ptr<Demo> ptr = std::make_unique<Demo>();
    ptr->greet();

    // ptr is automatically deleted when it goes out of scope
    return 0;
}
```

### 🧾 Output:

```
Demo created
Hello from unique_ptr
Demo destroyed
```

> ✅ No need to call `delete` – memory is automatically freed.

---

## 🔸 `std::shared_ptr` Example

```cpp
#include <iostream>
#include <memory>

class Demo {
public:
    Demo()  { std::cout << "Demo created\n"; }
    ~Demo() { std::cout << "Demo destroyed\n"; }
    void greet() { std::cout << "Hello from shared_ptr\n"; }
};

int main() {
    std::shared_ptr<Demo> ptr1 = std::make_shared<Demo>();
    std::shared_ptr<Demo> ptr2 = ptr1;  // shared ownership

    ptr1->greet();
    ptr2->greet();

    // Object is destroyed only when the last shared_ptr is destroyed
    return 0;
}
```

### 🧾 Output:

```
Demo created
Hello from shared_ptr
Hello from shared_ptr
Demo destroyed
```

> ✅ Automatically keeps track of how many `shared_ptr` point to the object.

---

## ⚠️ Warning: Don’t mix raw pointers and smart pointers.

Avoid this:

```cpp
std::unique_ptr<Demo> ptr(new Demo());  // OK, but prefer make_unique
Demo* raw = ptr.get();
delete raw;  // ❌ double delete!
```

---

## 🆚 When to Use What?

| Situation                             | Use          |
| ------------------------------------- | ------------ |
| Sole ownership                        | `unique_ptr` |
| Shared ownership (e.g., caching)      | `shared_ptr` |
| Prevent memory leaks in linked graphs | `weak_ptr`   |

---

## ✅ Summary

| Smart Pointer | Key Feature              | Destructor Called Automatically? |
| ------------- | ------------------------ | -------------------------------- |
| `unique_ptr`  | Exclusive ownership      | ✅ Yes                            |
| `shared_ptr`  | Ref-counted shared usage | ✅ Yes (when ref count = 0)       |
| `weak_ptr`    | Non-owning ref to shared | ❌ No                             |

---

