
---

## ‚úÖ What is RAII?

**RAII** stands for:

> **Resource Acquisition Is Initialization**

It‚Äôs a **C++ programming idiom** where **resources (like memory, files, sockets, etc.) are tied to the lifetime of objects**.

### üß† Core Idea:

When an object is created:

* It **acquires** a resource (in the constructor).
* When it goes **out of scope**, its **destructor automatically releases** the resource.

---

## üî• Why is RAII Useful?

It **prevents memory leaks** and **resource leaks** by ensuring:

* All resources are **automatically freed**, even if an exception occurs.
* You **don‚Äôt need to manually call `delete`, `close()`, or `free()`**.

---

## üß™ Real-Life Analogy

> Think of a locker room key:
>
> * When you **enter** the gym, you **get the key (resource acquisition)**.
> * When you're **done and leave**, you **return the key (resource release)**.

---

## üßæ Example: Without RAII (Manual Cleanup)

```cpp
void withoutRAII() {
    int* ptr = new int[10]; // manually allocated

    // do something...

    delete[] ptr; // must remember to delete, or leak happens
}
```

If an exception occurs before `delete[]`, the memory is leaked.

---

## ‚úÖ Example: With RAII

```cpp
#include <vector>

void withRAII() {
    std::vector<int> vec(10); // memory managed by vector

    // do something...

} // vector goes out of scope ‚Üí memory automatically freed
```

The memory is freed even if an exception is thrown or function returns early.

---

## üéØ How RAII Prevents Memory Leaks

Let‚Äôs say you create a class that handles file I/O:

```cpp
class FileHandler {
    FILE* file;
public:
    FileHandler(const char* filename) {
        file = fopen(filename, "r");
    }

    ~FileHandler() {
        if (file) fclose(file); // file is always closed
    }
};
```

Usage:

```cpp
void process() {
    FileHandler fh("data.txt");
    // do something with file...
} // Destructor automatically closes the file
```

Even if an exception occurs, `~FileHandler()` is called.

---

## üõ† Common STL Classes That Use RAII

| Resource        | RAII Class (C++ STL)                 |
| --------------- | ------------------------------------ |
| Dynamic memory  | `std::vector`, `std::string`         |
| File handles    | `std::ifstream`, `std::ofstream`     |
| Smart pointers  | `std::unique_ptr`, `std::shared_ptr` |
| Threads & locks | `std::thread`, `std::lock_guard`     |

---

## üîê In Modern C++ (C++11 and beyond)

You should **always prefer RAII** for:

* Memory ‚Üí `std::unique_ptr`, `std::shared_ptr`
* File/Socket/DB handles ‚Üí wrapper classes
* Mutex/Locks ‚Üí `std::lock_guard`

---

## üöÄ Summary

| Feature        | Description                                           |
| -------------- | ----------------------------------------------------- |
| **RAII**       | Binds resource to object lifetime                     |
| **Prevents**   | Memory leaks, file handle leaks, etc.                 |
| **Works With** | Memory, files, mutexes, sockets                       |
| **Used By**    | STL containers, smart pointers, C++ concurrency tools |

---
