Great! Here's how you can write a **custom LLVM pass** to **count the number of loops** in each function using the LLVM **LoopInfo analysis**.

---

## ‚úÖ Goal

Build an LLVM **Function Pass** that:

* Runs on each function
* Uses `LoopInfo` to detect natural loops
* Prints the **number of loops** per function

---

## üîß Prerequisites

Ensure you're using LLVM ‚â• 10 and CMake.

Install LLVM (if needed):

```bash
sudo apt install llvm-dev clang cmake
```

---

## üìÅ Directory Structure

```
LoopCounter/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îî‚îÄ‚îÄ LoopCounter.cpp
```

---

## ‚úÖ Step-by-Step Implementation

### üìò `LoopCounter.cpp`

```cpp
#include "llvm/IR/Function.h"
#include "llvm/IR/PassManager.h"
#include "llvm/Pass.h"
#include "llvm/IR/Instructions.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/IR/CFG.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

namespace {
struct LoopCounterPass : public PassInfoMixin<LoopCounterPass> {
  PreservedAnalyses run(Function &F, FunctionAnalysisManager &FAM) {
    LoopInfo &LI = FAM.getResult<LoopAnalysis>(F);

    int loopCount = 0;
    for (auto &L : LI) {
      loopCount += countLoops(L);
    }

    errs() << "Function '" << F.getName() << "' contains " << loopCount << " loop(s).\n";

    return PreservedAnalyses::all();
  }

  int countLoops(Loop *L) {
    int count = 1; // count this loop
    for (Loop *SubLoop : *L) {
      count += countLoops(SubLoop);
    }
    return count;
  }
};
} // namespace

// Register the pass with the "opt-new" pass manager
llvm::PassPluginLibraryInfo getLoopCounterPluginInfo() {
  return {LLVM_PLUGIN_API_VERSION, "LoopCounterPass", LLVM_VERSION_STRING,
          [](PassBuilder &PB) {
            PB.registerPipelineParsingCallback(
                [](StringRef Name, FunctionPassManager &FPM,
                   ArrayRef<PassBuilder::PipelineElement>) {
                  if (Name == "loop-counter") {
                    FPM.addPass(LoopCounterPass());
                    return true;
                  }
                  return false;
                });
          }};
}

// Export the plugin
extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo
llvmGetPassPluginInfo() {
  return getLoopCounterPluginInfo();
}
```

---

### üì¶ `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.13)
project(LoopCounterPass VERSION 1.0 LANGUAGES CXX)

find_package(LLVM REQUIRED CONFIG)

message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")

list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
include(HandleLLVMOptions)

add_library(LoopCounter MODULE LoopCounter.cpp)

set_target_properties(LoopCounter PROPERTIES
  COMPILE_FLAGS "-fno-rtti"
)

target_include_directories(LoopCounter PRIVATE ${LLVM_INCLUDE_DIRS})
target_link_libraries(LoopCounter PRIVATE LLVMCore LLVMAnalysis LLVMSupport)
```

---

## üß™ Build the Pass

```bash
mkdir build && cd build
cmake ..
make
```

---

## ‚úÖ Run the Pass with `opt`

Create a test file `test.ll`:

```llvm
define void @test_loop() {
entry:
  br label %loop

loop:
  %i = phi i32 [ 0, %entry ], [ %next, %loop ]
  %cond = icmp slt i32 %i, 10
  %next = add i32 %i, 1
  br i1 %cond, label %loop, label %exit

exit:
  ret void
}
```

Then run:

```bash
opt -load-pass-plugin ./libLoopCounter.so -passes="loop(counter)" -disable-output test.ll
```

You should see:

```
Function 'test_loop' contains 1 loop(s).
```

---

## ‚úÖ Summary

| Feature        | Description                     |
| -------------- | ------------------------------- |
| LLVM Pass Type | Function Pass                   |
| Uses           | `LoopInfo` analysis             |
| Counts         | Nested loops recursively        |
| Output         | Prints to `stderr` via `errs()` |

---

Would you like to extend this pass to:

* Count **nested depth of loops**?
* Count **instructions inside loops**?
* Or transform loops (e.g., unroll)?
