
---

## üöÄ What is Kaleidoscope?

**Kaleidoscope** is a **step-by-step LLVM tutorial** that teaches how to:

* Write a **simple language**
* Parse it
* Generate LLVM IR
* Run or JIT compile it

---

## üõ†Ô∏è What We'll Build

A basic version of Kaleidoscope includes:

| Component      | Description                     |
| -------------- | ------------------------------- |
| Lexer          | Tokenizes input                 |
| Parser         | Parses tokens into an AST       |
| Code Generator | Emits LLVM IR                   |
| REPL           | Runs the language interactively |

---

## üì¶ Requirements

Install **LLVM**:

```bash
sudo apt install llvm clang libedit-dev cmake
```

Make sure LLVM version is 10 or higher.

---

## üìÅ Folder Structure

```bash
kaleidoscope/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ main.cpp
```

---

## ‚úÖ Step-by-Step: Minimal Kaleidoscope

### 1Ô∏è‚É£ `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.13)
project(Kaleidoscope)

find_package(LLVM REQUIRED CONFIG)
list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
include(HandleLLVMOptions)
include(AddLLVM)

add_definitions(${LLVM_DEFINITIONS})
include_directories(${LLVM_INCLUDE_DIRS})

add_executable(kaleidoscope main.cpp)
llvm_map_components_to_libnames(llvm_libs support core irreader orcjit native)

target_link_libraries(kaleidoscope ${llvm_libs})
```

---

### 2Ô∏è‚É£ `main.cpp` ‚Äì Minimal Kaleidoscope

```cpp
#include "llvm/ADT/STLExtras.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Verifier.h"
#include <cctype>
#include <cstdio>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <vector>

using namespace llvm;
using namespace std;

static LLVMContext TheContext;
static IRBuilder<> Builder(TheContext);
static unique_ptr<Module> TheModule;
static map<string, Value *> NamedValues;

/// ExprAST - Base class for all expressions.
class ExprAST {
public:
  virtual ~ExprAST() = default;
  virtual Value *codegen() = 0;
};

/// NumberExprAST - Expression class for numeric literals like "1.0".
class NumberExprAST : public ExprAST {
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) {}
  Value *codegen() override {
    return ConstantFP::get(TheContext, APFloat(Val));
  }
};

/// VariableExprAST - For variables like "a".
class VariableExprAST : public ExprAST {
  string Name;

public:
  VariableExprAST(string Name) : Name(Name) {}
  Value *codegen() override {
    Value *V = NamedValues[Name];
    if (!V)
      cerr << "Unknown variable: " << Name << endl;
    return V;
  }
};

/// BinaryExprAST - Binary operations like "+" or "*".
class BinaryExprAST : public ExprAST {
  char Op;
  unique_ptr<ExprAST> LHS, RHS;

public:
  BinaryExprAST(char Op, unique_ptr<ExprAST> LHS, unique_ptr<ExprAST> RHS)
      : Op(Op), LHS(move(LHS)), RHS(move(RHS)) {}
  Value *codegen() override {
    Value *L = LHS->codegen();
    Value *R = RHS->codegen();
    if (!L || !R)
      return nullptr;

    switch (Op) {
    case '+':
      return Builder.CreateFAdd(L, R, "addtmp");
    case '-':
      return Builder.CreateFSub(L, R, "subtmp");
    case '*':
      return Builder.CreateFMul(L, R, "multmp");
    case '<':
      L = Builder.CreateFCmpULT(L, R, "cmptmp");
      return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), "booltmp");
    default:
      cerr << "Invalid binary operator" << endl;
      return nullptr;
    }
  }
};

/// PrototypeAST - Function prototype.
class PrototypeAST {
  string Name;
  vector<string> Args;

public:
  PrototypeAST(string Name, vector<string> Args)
      : Name(Name), Args(move(Args)) {}

  Function *codegen() {
    vector<Type *> Doubles(Args.size(), Type::getDoubleTy(TheContext));
    FunctionType *FT =
        FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);
    Function *F =
        Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());

    unsigned Idx = 0;
    for (auto &Arg : F->args())
      Arg.setName(Args[Idx++]);
    return F;
  }

  const string &getName() const { return Name; }
};

/// FunctionAST - Full function definition.
class FunctionAST {
  unique_ptr<PrototypeAST> Proto;
  unique_ptr<ExprAST> Body;

public:
  FunctionAST(unique_ptr<PrototypeAST> Proto, unique_ptr<ExprAST> Body)
      : Proto(move(Proto)), Body(move(Body)) {}

  Function *codegen() {
    Function *F = Proto->codegen();
    if (!F)
      return nullptr;

    BasicBlock *BB = BasicBlock::Create(TheContext, "entry", F);
    Builder.SetInsertPoint(BB);

    NamedValues.clear();
    for (auto &Arg : F->args())
      NamedValues[string(Arg.getName())] = &Arg;

    if (Value *RetVal = Body->codegen()) {
      Builder.CreateRet(RetVal);
      verifyFunction(*F);
      return F;
    }

    F->eraseFromParent();
    return nullptr;
  }
};

int main() {
  TheModule = make_unique<Module>("toy compiler", TheContext);

  auto Proto = make_unique<PrototypeAST>("test", vector<string>{"a", "b"});
  auto LHS = make_unique<VariableExprAST>("a");
  auto RHS = make_unique<VariableExprAST>("b");
  auto Body = make_unique<BinaryExprAST>('+', move(LHS), move(RHS));
  auto Func = make_unique<FunctionAST>(move(Proto), move(Body));

  Func->codegen();

  TheModule->print(outs(), nullptr);

  return 0;
}
```

---

## üß™ Build and Run

```bash
mkdir build && cd build
cmake ..
make
./kaleidoscope
```

### ‚úÖ Output (LLVM IR)

```llvm
define double @test(double %a, double %b) {
entry:
  %addtmp = fadd double %a, %b
  ret double %addtmp
}
```

---

## üß† What You Learned

* ‚úÖ Created a working toy language (Kaleidoscope)
* üß† Built AST nodes
* üõ† Generated LLVM IR from C++ AST
* üì§ Printed final LLVM IR

---

## üöß Next Steps (Optional)

1. Add a **Lexer**
2. Add a **Parser**
3. Implement `if`, `for`, functions, and JIT
4. Integrate `libclang` for syntax support

