
---

## âœ… What is Bison?

**Bison** is a **parser generator** that:

* Takes a **grammar file** (usually `.y`) and produces a **C/C++ parser**.
* **Parses tokens** generated by a lexer (like Flex) and **checks for syntax correctness**.
* Typically used to **build compilers, interpreters, or expression evaluators**.

---

### ðŸ”¹ How Bison Works

1. **Define Grammar Rules**

   * Write a `.y` file specifying **tokens** and **production rules**.

2. **Generate Parser**

```bash
bison -d parser.y
```

* Produces `parser.tab.c` (parser code) and `parser.tab.h` (token definitions).

3. **Compile with Lexer**

```bash
g++ lex.yy.c parser.tab.c -o parser -lfl
```

4. **Run the Parser**

* Reads input, matches tokens to grammar rules, and executes actions.

---

### ðŸ”¹ Key Concepts

| Term                | Explanation                                                         |
| ------------------- | ------------------------------------------------------------------- |
| **Token**           | Smallest unit from lexer (`NUMBER`, `PLUS`)                         |
| **Non-terminal**    | Grammar symbol representing multiple tokens or rules (`expression`) |
| **Production rule** | Defines how tokens/non-terminals combine (`expr: expr '+' expr`)    |
| **Action**          | C/C++ code executed when rule matches (`{ $$ = $1 + $3; }`)         |

---

### ðŸ”¹ Example Grammar Rule (Arithmetic Expressions)

```bison
%token NUMBER
%left '+' '-'
%left '*' '/'

%%

expr:
      expr '+' expr { cout << $1 + $3 << endl; }
    | expr '-' expr { cout << $1 - $3 << endl; }
    | expr '*' expr { cout << $1 * $3 << endl; }
    | expr '/' expr { cout << $1 / $3 << endl; }
    | NUMBER        { $$ = atoi(yytext); }
    ;

%%
```

* **Tokens** like `NUMBER` come from Flex.
* **Actions** inside `{ ... }` calculate the result.
* **`$$`** represents the value of the current non-terminal (`expr`).
* **`$1`, `$3`** are values of matched tokens/non-terminals in the rule.

---

### ðŸ”¹ Real-World Use Cases

* Compilers: Parse **C/C++, Java, Python** source code.
* Expression evaluators: Build calculators.
* Configuration file parsers.

---

