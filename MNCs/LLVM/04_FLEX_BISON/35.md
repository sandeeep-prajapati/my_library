
---

## âœ… Step 1: Create the Bison Grammar (`calc.y`)

```c
%{
#include <iostream>
#include <cstdlib>
using namespace std;

int yylex();
void yyerror(const char *s);

int result;  // store final result
%}

%token NUMBER
%left '+' '-'
%left '*' '/'

%%

calculation:
    expr '\n'    { cout << "Result: " << $1 << endl; result = $1; }
    ;

expr:
      expr '+' expr   { $$ = $1 + $3; }
    | expr '-' expr   { $$ = $1 - $3; }
    | expr '*' expr   { $$ = $1 * $3; }
    | expr '/' expr   { 
                          if ($3 == 0) {
                              cout << "Error: Division by zero!" << endl;
                              $$ = 0;
                          } else {
                              $$ = $1 / $3;
                          }
                       }
    | '(' expr ')'    { $$ = $2; }
    | NUMBER          { $$ = $1; }
    ;

%%

void yyerror(const char *s) {
    cerr << "Error: " << s << endl;
}

int main() {
    cout << "Enter arithmetic expressions (Ctrl+C to exit):" << endl;
    yyparse();  // start parsing
    return 0;
}
```

---

## âœ… Step 2: Create the Flex Lexer (`calc.l`)

```c
%{
#include "calc.tab.h"
#include <cstdlib>
#include <iostream>
using namespace std;

extern int yylval;
%}

%%

[0-9]+      { yylval = atoi(yytext); return NUMBER; }
[+\-*/\(\)] { return yytext[0]; }
[ \t]+      { /* ignore spaces and tabs */ }
\n          { return '\n'; }
.           { cout << "Unknown character: " << yytext << endl; }

%%
int yywrap() { return 1; }
```

---

## âœ… Step 3: Compile and Link

```bash
bison -d calc.y         # Generates calc.tab.c and calc.tab.h
flex calc.l              # Generates lex.yy.c
g++ calc.tab.c lex.yy.c -o calc -lfl
```

---

## âœ… Step 4: Run the Calculator

```bash
./calc
```

**Example Input:**

```
2 + 3 * 4
```

**Output:**

```
Result: 14
```

---

**Another Input:**

```
(10 + 5) / 3
```

**Output:**

```
Result: 5
```

---

### ðŸ”¹ How It Works

1. **Flex** tokenizes input into `NUMBER`, operators, and parentheses.
2. **Bison** parses tokens based on grammar rules and evaluates the expression.
3. **Operator precedence** (`%left`) ensures `*` and `/` are evaluated before `+` and `-`.
4. **Parentheses** allow grouping.
5. Division by zero is handled gracefully.

---

### ðŸ’¡ Challenge:

* Add support for **unary minus** (negative numbers).
* Add **floating-point numbers** instead of integers.

---

