Perfect! Letâ€™s create a **simple calculator lexer** using Flex. This will **tokenize numbers and operators**.

---

## âœ… `calc.l` â€” Simple Calculator Lexer

```c
%{
#include <iostream>
using namespace std;
%}

%%

[0-9]+      { cout << "NUMBER: " << yytext << endl; }
[\+\-\*/]   { cout << "OPERATOR: " << yytext << endl; }
[ \t\n]+    { /* ignore whitespace */ }
.           { cout << "UNKNOWN: " << yytext << endl; }

%%

int main() {
    cout << "Enter expression: ";
    yylex();  // Start scanning input
    return 0;
}
```

---

### ðŸ”¹ How to Compile and Run

1. Generate C code from `.l` file:

```bash
flex calc.l
```

2. Compile with `g++`:

```bash
g++ lex.yy.c -o calc -lfl
```

3. Run the program:

```bash
./calc
```

---

### ðŸ”¹ Sample Input & Output

**Input:**

```
12 + 34 - 5 * 2
```

**Output:**

```
Enter expression: NUMBER: 12
OPERATOR: +
NUMBER: 34
OPERATOR: -
NUMBER: 5
OPERATOR: *
NUMBER: 2
```

---

### ðŸ”¹ Key Points

| Concept     | Explanation                   |
| ----------- | ----------------------------- |
| `[0-9]+`    | Matches integers (numbers)    |
| `[\+\-\*/]` | Matches operators +, -, *, /  |
| `[ \t\n]+`  | Ignore spaces, tabs, newlines |
| `yytext`    | Contains matched text         |

---

### ðŸ’¡ Challenge:

* Modify `calc.l` to also **recognize parentheses** `(` and `)` as separate tokens.
* Test it with an expression like: `(2 + 3) * 4`.
