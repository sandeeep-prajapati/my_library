
---

### âœ… What is a `phi` Node?

A **`phi` node** in LLVM IR is used to merge multiple control flow paths in **SSA (Static Single Assignment)** form.

> ğŸ§  It selects a value **based on which basic block the control came from**.

---

### ğŸ”§ Basic Syntax

```llvm
%result = phi <type> [ <value1>, <label1> ], [ <value2>, <label2> ], ...
```

This means:

* If control comes from `label1`, use `value1`
* If control comes from `label2`, use `value2`
* And so on...

---

### ğŸ“˜ Example: `if-else` in C++

```cpp
int x;
if (cond)
    x = 1;
else
    x = 2;
// use x
```

### ğŸ”„ SSA + IR with `phi` Node

```llvm
entry:
  br i1 %cond, label %if.then, label %if.else

if.then:
  br label %merge

if.else:
  br label %merge

merge:
  %x = phi i32 [ 1, %if.then ], [ 2, %if.else ]
  ; now use %x
```

ğŸ§  Here, `%x` gets:

* `1` if control came from `if.then`
* `2` if from `if.else`

---

### ğŸ” Example: Loop with `phi` Node

```cpp
int sum = 0;
for (int i = 0; i < 4; i++) {
    sum += i;
}
```

### ğŸ”„ IR with `phi` Nodes for `i` and `sum`

```llvm
entry:
  br label %loop

loop:
  ; PHI nodes: initial values come from 'entry', updated values from 'loop'
  %i = phi i32 [ 0, %entry ], [ %i_next, %loop ]
  %sum = phi i32 [ 0, %entry ], [ %sum_next, %loop ]

  ; do computation
  %sum_next = add i32 %sum, %i
  %i_next = add i32 %i, 1

  ; loop condition
  %cond = icmp slt i32 %i_next, 4
  br i1 %cond, label %loop, label %after

after:
  ; %sum_next is the final sum
```

ğŸ¯ The `phi` nodes allow SSA to represent changing variables (`i`, `sum`) over iterations.

---

### âœ… Summary

| Concept       | Description                                          |
| ------------- | ---------------------------------------------------- |
| `phi` node    | Selects value based on control path                  |
| Used in       | Conditionals (`if-else`), loops                      |
| Needed in SSA | Because each variable must have a single assignment  |
| Syntax        | `%var = phi type [ val1, label1 ], [ val2, label2 ]` |

---
