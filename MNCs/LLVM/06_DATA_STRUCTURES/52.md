In **LLVM (Low-Level Virtual Machine)**, the **Static Single Assignment (SSA) form** is a **core principle** and **default representation** of all variables in the **LLVM Intermediate Representation (IR)**.

---

### ‚úÖ What is SSA?

**Static Single Assignment (SSA)** form means that:

> ‚ú≥Ô∏è **Each variable is assigned exactly once**, and every variable is **defined before it is used**.

If a variable is updated multiple times in source code, in SSA form, **each update results in a new version of the variable**.

---

### üîß Example Before SSA

C/C++ code:

```cpp
int x = 1;
if (cond) {
    x = 2;
}
printf("%d", x);
```

Without SSA:

```llvm
%x = alloca i32
store i32 1, i32* %x
br i1 %cond, label %if.then, label %if.end

if.then:
  store i32 2, i32* %x
  br label %if.end

if.end:
  %val = load i32, i32* %x
  call void @printf(i32 %val)
```

---

### üîÅ In SSA Form with `phi` Node

```llvm
; Assume %cond is a boolean
entry:
  br i1 %cond, label %if.then, label %if.else

if.then:
  %x1 = add i32 0, 1    ; equivalent to x = 1
  br label %merge

if.else:
  %x2 = add i32 0, 2    ; equivalent to x = 2
  br label %merge

merge:
  %x = phi i32 [ %x1, %if.then ], [ %x2, %if.else ]
  call void @printf(i32 %x)
```

---

### üîÅ SSA Maintenance in LLVM

LLVM maintains SSA form by:

#### 1. **Assigning New Registers for Every Definition**

* Registers in LLVM IR are in SSA: `%x`, `%y`, etc.
* Every assignment produces a **new virtual register**.

#### 2. **Using `phi` Nodes** at Control Flow Merge Points

* When control flow merges (e.g., after `if` or loop), LLVM inserts a `phi` node to **select the correct value** depending on the origin block.
* Syntax:

  ```llvm
  %x = phi i32 [ %x1, %if.then ], [ %x2, %if.else ]
  ```

#### 3. **Using Dominator Tree Analysis**

* LLVM builds a **dominator tree** to determine where to insert `phi` nodes.
* A block A dominates block B if **every path to B must go through A**.

#### 4. **Mem2Reg Pass**

* Converts code using memory (`alloca` + `load`/`store`) into SSA registers.
* Run using: `opt -mem2reg file.ll -S -o output.ll`

---

### üìö Tools and Passes

* **`opt`**: LLVM optimizer (for SSA transformations)
* **`mem2reg`**: Promotes memory variables to SSA registers
* **`-dot-cfg`** or **`-view-cfg`**: View control flow graph
* **`-instnamer`**: Names unnamed instructions for easier reading

---

### ‚úÖ Summary

| Feature           | Role in SSA                              |
| ----------------- | ---------------------------------------- |
| Unique assignment | Each variable version is distinct        |
| `phi` nodes       | Resolve multiple values at control merge |
| `mem2reg` pass    | Converts memory-based code to SSA        |
| Dominator Tree    | Guides `phi` node placement              |

---
