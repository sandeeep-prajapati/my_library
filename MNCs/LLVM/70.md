Great! Let's build a **C++ tool** using the **LLVM C++ API** that:

> ‚úÖ **Reads LLVM IR**,
> ‚úÖ **Parses it into a Module**,
> ‚úÖ **Analyzes function call depth** (i.e., how deeply functions call each other).

---

## üîç What is Function Call Depth?

Function call depth is:

* The **longest path** of function calls starting from a given function.
* For example, if `A()` calls `B()`, and `B()` calls `C()`, then `A()` has a call depth of **3**.

---

## üì¶ Tool Overview

* ‚úÖ Input: LLVM IR file (`.ll` or `.bc`)
* ‚úÖ Output: For each function, print its **max call depth**
* üß† Strategy: Recursively traverse the call graph

---

## üìÅ File: `CallDepthAnalyzer.cpp`

```cpp
#include "llvm/IR/Module.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <unordered_map>
#include <unordered_set>
#include <algorithm>

using namespace llvm;

cl::opt<std::string> InputFilename(cl::Positional, cl::desc("<input LLVM IR file>"), cl::Required);

/// Call graph cache to memoize depth computations
std::unordered_map<std::string, int> CallDepthMap;

/// Set to detect recursion
std::unordered_set<std::string> Visited;

int getCallDepth(Function &F) {
    std::string FuncName = F.getName().str();

    // If we've already computed the depth, return it
    if (CallDepthMap.count(FuncName))
        return CallDepthMap[FuncName];

    // Detect recursion
    if (Visited.count(FuncName)) {
        errs() << "Warning: recursion detected in function " << FuncName << "\n";
        return 0;
    }

    Visited.insert(FuncName);

    int maxDepth = 1; // base depth

    for (auto &BB : F) {
        for (auto &I : BB) {
            if (auto *call = dyn_cast<CallBase>(&I)) {
                Function *callee = call->getCalledFunction();
                if (callee && !callee->isDeclaration()) {
                    maxDepth = std::max(maxDepth, 1 + getCallDepth(*callee));
                }
            }
        }
    }

    Visited.erase(FuncName);
    CallDepthMap[FuncName] = maxDepth;
    return maxDepth;
}

int main(int argc, char **argv) {
    LLVMContext Context;
    cl::ParseCommandLineOptions(argc, argv, "LLVM Function Call Depth Analyzer\n");

    SMDiagnostic Err;
    std::unique_ptr<Module> M = parseIRFile(InputFilename, Err, Context);

    if (!M) {
        Err.print(argv[0], errs());
        return 1;
    }

    outs() << "Analyzing call depth for module: " << InputFilename << "\n";

    for (Function &F : *M) {
        if (!F.isDeclaration()) {
            int depth = getCallDepth(F);
            outs() << "Function '" << F.getName() << "' has call depth: " << depth << "\n";
        }
    }

    return 0;
}
```

---

## üì¶ Build with CMake

### üõ†Ô∏è `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.13)
project(CallDepthAnalyzer)

find_package(LLVM REQUIRED CONFIG)
include_directories(${LLVM_INCLUDE_DIRS})
add_definitions(${LLVM_DEFINITIONS})

add_executable(call_depth CallDepthAnalyzer.cpp)

llvm_map_components_to_libnames(llvm_libs core irreader support)

target_link_libraries(call_depth ${llvm_libs})
```

---

## ‚úÖ Build & Run

```bash
mkdir build && cd build
cmake ..
make
./call_depth test.ll
```

---

## üß™ Example LLVM IR: `test.ll`

```llvm
define void @A() {
  call void @B()
  ret void
}

define void @B() {
  call void @C()
  ret void
}

define void @C() {
  ret void
}
```

### üîÑ Output:

```
Analyzing call depth for module: test.ll
Function 'A' has call depth: 3
Function 'B' has call depth: 2
Function 'C' has call depth: 1
```

---

## üß† Bonus Features (Ideas)

| Feature              | Description                      |
| -------------------- | -------------------------------- |
| üîÑ Detect recursion  | Already implemented with warning |
| üìä Export call graph | Output DOT/JSON format           |
| üßµ Parallel analysis | Use threads for big modules      |
| üîé CLI filters       | Analyze only specific functions  |

---

## ‚úÖ Summary

| Component           | Tool                                  |
| ------------------- | ------------------------------------- |
| LLVM API Used       | `parseIRFile`, `Function`, `CallBase` |
| Recursion detection | ‚úÖ Yes                                 |
| Memoization         | ‚úÖ Yes (for speed)                     |
| Output              | Function name + call depth            |

---

Would you like to:

* Generate a call graph image?
* Export data to a file (CSV/JSON)?
* Turn this into an **LLVM Module Pass**?

Let me know how you'd like to enhance it!
