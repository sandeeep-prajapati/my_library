# âš¡ Optimizing Oracle Connectors for High-Throughput Reads & Writes

To get max performance, you must tune **four layers together**:

1. **Connection Pooling**
2. **Fetch Size (Reads)**
3. **Batch Inserts / Updates (Writes)**
4. **Commit Strategies (Transactions)**

Miss one â†’ bottleneck.

---

## 1ï¸âƒ£ Connection Pooling (Non-Negotiable)

Opening an Oracle connection is **expensive**. Never do per-request connections.

### âœ… Best Practices

* Use **HikariCP** (JDBC) or native pool (OCI)
* Pool size â‰ˆ DB CPU cores Ã— 2
* Reuse connections aggressively

### ğŸ”§ Recommended Settings (JDBC)

```properties
maximumPoolSize=20
minimumIdle=5
connectionTimeout=30000
idleTimeout=600000
maxLifetime=1800000
```

### âš ï¸ Anti-Patterns

âŒ Creating connection per query
âŒ Pool size too large â†’ DB thrashing
âŒ Long-lived transactions in pool

---

## 2ï¸âƒ£ Fetch Size (High-Speed Reads)

Fetch size controls **rows per network round-trip**.

### ğŸ”§ JDBC Fetch Size

```java
stmt.setFetchSize(1000);
```

### ğŸ“ˆ Performance Impact

| Fetch Size | Network Trips | Throughput     |
| ---------- | ------------- | -------------- |
| 10         | Very High     | âŒ Slow         |
| 1000       | Low           | âœ… Optimal      |
| 10000      | Very Low      | âš ï¸ Memory risk |

### ğŸ§  Rule of Thumb

* OLTP reads â†’ `100â€“500`
* ETL / CDC â†’ `1000â€“5000`

---

## 3ï¸âƒ£ Batch Inserts & Updates (Write Fast)

Oracle is **extremely fast at batching**.

### ğŸ”§ JDBC Batch Insert

```java
PreparedStatement ps = conn.prepareStatement(sql);

for (int i = 0; i < data.size(); i++) {
  ps.setString(1, data.get(i));
  ps.addBatch();

  if (i % 1000 == 0) {
    ps.executeBatch();
  }
}
ps.executeBatch();
```

### ğŸ“Š Batch Size Guidelines

| Batch Size | Use Case  |
| ---------- | --------- |
| 100        | OLTP      |
| 1000       | ETL       |
| 5000       | Bulk load |

âŒ Too large â†’ rollback segment pressure
âŒ Too small â†’ network overhead

---

## 4ï¸âƒ£ Commit Strategies (Critical!)

**Commit cost is HUGE** in Oracle.

### âŒ Bad Strategy

```sql
COMMIT; -- after every row
```

### âœ… Optimized Strategy

```sql
COMMIT; -- after batch
```

### ğŸ¯ Commit Frequency

| Scenario   | Commit                   |
| ---------- | ------------------------ |
| API writes | Per request              |
| ETL loads  | Every 1000â€“5000 rows     |
| Kafka CDC  | Time-based + count-based |

### âš ï¸ Risk Management

* Long transactions â†’ undo pressure
* Frequent commits â†’ redo overhead

---

## 5ï¸âƒ£ Oracle-Specific Power Tricks âš¡

### ğŸ”¹ Use `executeBatch()` with `rewriteBatchedStatements`

```properties
oracle.jdbc.batchPerformanceWorkaround=true
```

### ğŸ”¹ Disable auto-commit

```java
conn.setAutoCommit(false);
```

### ğŸ”¹ Use `INSERT /*+ APPEND */` (Bulk Load)

âœ” Direct path insert
âŒ Table locking

---

## 6ï¸âƒ£ End-to-End Optimized Pattern

```text
Connection Pool
     â†“
Prepared Statement
     â†“
FetchSize = 1000
     â†“
Batch = 1000
     â†“
Commit
```

---

## ğŸ“Š Performance Summary Table

| Area        | Default     | Optimized |
| ----------- | ----------- | --------- |
| Connections | Per request | Pool      |
| Fetch size  | 10          | 1000      |
| Inserts     | Single      | Batch     |
| Commits     | Per row     | Per batch |
| Throughput  | âŒ Low       | ğŸš€ High   |

---

## ğŸ§  Interview One-Liner (Perfect Answer)

> â€œHigh-throughput Oracle connectors rely on connection pooling, tuned fetch sizes to reduce round trips, batched writes to minimize redo and network overhead, and controlled commit frequency to balance durability with performance.â€
