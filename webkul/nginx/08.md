# 1ï¸âƒ£ API Gateway Architecture

```
Client
   â†“
 NGINX (API Gateway)
   â”œâ”€â”€ Auth & Rate Limit
   â”œâ”€â”€ CORS
   â”œâ”€â”€ Logging
   â””â”€â”€ Routing / Versioning
        â†“
   Microservices (Node / Go / Django)
```

---

# 2ï¸âƒ£ Authentication (API Key Based)

### Client Header

```
X-API-Key: abc123
```

### Define Allowed Keys

```nginx
map $http_x_api_key $api_key_valid {
    default 0;
    abc123 1;
    xyz789 1;
}
```

### Enforce Auth

```nginx
server {
    location /api/ {
        if ($api_key_valid = 0) {
            return 401;
        }
        proxy_pass http://api_backend;
    }
}
```

âœ” Fast
âœ” Stateless
âœ” No backend load

---

# 3ï¸âƒ£ Rate Limiting (Per Client)

```nginx
limit_req_zone $binary_remote_addr zone=api_rate:10m rate=20r/s;
```

```nginx
location /api/ {
    limit_req zone=api_rate burst=40 nodelay;
    proxy_pass http://api_backend;
}
```

âœ” Prevent abuse
âœ” Smooth bursts
âœ” Backend stays healthy

---

# 4ï¸âƒ£ CORS Handling (Centralized)

```nginx
location /api/ {
    add_header 'Access-Control-Allow-Origin' '*';
    add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS';
    add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type, X-API-Key';
    add_header 'Access-Control-Allow-Credentials' 'true';

    if ($request_method = OPTIONS) {
        return 204;
    }

    proxy_pass http://api_backend;
}
```

âœ” Browser-safe
âœ” No CORS logic in backend

---

# 5ï¸âƒ£ API Versioning (Clean & Scalable)

### Version-Based Routing

```nginx
upstream api_v1 {
    server 127.0.0.1:3001;
}

upstream api_v2 {
    server 127.0.0.1:3002;
}
```

```nginx
location /api/v1/ {
    proxy_pass http://api_v1;
}

location /api/v2/ {
    proxy_pass http://api_v2;
}
```

âœ” Parallel versions
âœ” Easy rollback
âœ” Zero downtime upgrades

---

# 6ï¸âƒ£ Request Logging (Gateway-Level Observability)

### JSON Log Format

```nginx
log_format api_json escape=json
'{'
 '"time":"$time_iso8601",'
 '"ip":"$remote_addr",'
 '"method":"$request_method",'
 '"uri":"$request_uri",'
 '"status":$status,'
 '"response_time":$request_time,'
 '"upstream":"$upstream_addr"'
 '}';
```

```nginx
access_log /var/log/nginx/api.log api_json;
```

âœ” Easy ELK ingestion
âœ” API performance insights
âœ” Debugging superpower

---

# 7ï¸âƒ£ Timeouts & Retries (Gateway Control)

```nginx
proxy_connect_timeout 5s;
proxy_read_timeout 30s;
proxy_send_timeout 30s;

proxy_next_upstream error timeout http_502 http_503 http_504;
```

âœ” Automatic failover
âœ” Faster error responses

---

# 8ï¸âƒ£ Complete API Gateway Example

```nginx
http {
    limit_req_zone $binary_remote_addr zone=api_rate:10m rate=20r/s;

    map $http_x_api_key $api_key_valid {
        default 0;
        abc123 1;
    }

    log_format api_json escape=json
    '{'
     '"ip":"$remote_addr",'
     '"method":"$request_method",'
     '"uri":"$request_uri",'
     '"status":$status,'
     '"rt":$request_time'
    '}';
}

server {
    listen 80;
    server_name api.example.com;

    access_log /var/log/nginx/api.log api_json;

    location /api/ {
        if ($api_key_valid = 0) { return 401; }

        limit_req zone=api_rate burst=40 nodelay;

        add_header Access-Control-Allow-Origin '*';
        add_header Access-Control-Allow-Headers 'Authorization, Content-Type, X-API-Key';
        add_header Access-Control-Allow-Methods 'GET, POST, PUT, DELETE, OPTIONS';

        if ($request_method = OPTIONS) { return 204; }

        proxy_pass http://api_backend;
    }

    location /api/v1/ {
        proxy_pass http://api_v1;
    }

    location /api/v2/ {
        proxy_pass http://api_v2;
    }
}
```

---

# 9ï¸âƒ£ When Nginx Is Enough (and When Itâ€™s Not)

âœ” Nginx is great for:

* Smallâ€“medium microservices
* Edge security
* Simple auth
* High performance

âŒ Consider dedicated gateways when:

* OAuth flows
* Dynamic policies
* Multi-tenant auth
* GraphQL federation

---

# ğŸ¯ Interview-Ready Summary (30 sec)

> â€œI use Nginx as an API gateway to centralize authentication, rate limiting, CORS handling, structured logging, and version-based routing. This offloads security and traffic control from backend services while maintaining high performance.â€

---

# ğŸ§  Pro Tips

* Store API keys in **Redis via lua** for scale
* Use **JWT validation** with `auth_request`
* Combine with **Prometheus exporter**
* Pair with **Cloudflare** for L7 DDoS

---
