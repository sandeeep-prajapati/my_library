## 1ï¸âƒ£ Nginx Architecture (Masterâ€“Worker Model)

Nginx uses a **master process + multiple worker processes**.

### ğŸ”¹ Master Process

* Runs as **root**
* Responsibilities:

  * Read & validate config files
  * Bind to privileged ports (80, 443)
  * Start / stop / restart worker processes
  * Handle reloads **without downtime**

ğŸ‘‰ The master **never handles client requests**.

---

### ğŸ”¹ Worker Processes

* Run as a **non-root user** (e.g. `www-data`)
* Each worker:

  * Handles **thousands of connections**
  * Uses **event-driven, non-blocking I/O**
* Workers are independent â†’ no locking overhead

```nginx
worker_processes auto;
```

* `auto` = one worker per CPU core (recommended)

---

## 2ï¸âƒ£ Event-Driven & Non-Blocking I/O (Key to Performance)

Nginx uses OS-level event mechanisms:

* **epoll** (Linux)
* **kqueue** (macOS / BSD)

### How it works:

* A worker **does not block** waiting for I/O
* While one request waits for disk/network:

  * Worker handles **other requests**
* One worker can manage **10kâ€“100k connections**

Think of it like:

> â€œOne waiter serving many tables at once instead of one waiter per table.â€

---

## 3ï¸âƒ£ How Nginx Handles Concurrent Requests

### Request Flow

1. Client connects to Nginx
2. Connection is registered with epoll
3. Worker reacts **only when events occur**
4. No thread creation
5. Minimal memory usage

### Important Setting

```nginx
events {
    worker_connections 10240;
}
```

**Max connections =**

```
worker_processes Ã— worker_connections
```

Example:

```
4 workers Ã— 10240 = ~40,000 concurrent connections
```

---

## 4ï¸âƒ£ Apache Architecture (Why Itâ€™s Slower by Default)

Apache traditionally uses **process/thread-based models**.

### Common Apache MPMs

| MPM     | Model                   |
| ------- | ----------------------- |
| prefork | 1 process per request   |
| worker  | threads per request     |
| event   | improved, still heavier |

### Apache Behavior

* Each request:

  * Uses a **thread or process**
* Idle connections:

  * Still consume memory
* High traffic:

  * High RAM usage
  * Context switching overhead

---

## 5ï¸âƒ£ Nginx vs Apache (Concurrency Comparison)

| Feature      | Nginx                      | Apache                 |
| ------------ | -------------------------- | ---------------------- |
| Architecture | Event-driven               | Process / Thread-based |
| Memory usage | Very low                   | Higher                 |
| Concurrency  | Excellent                  | Limited                |
| Static files | ğŸ”¥ Extremely fast          | Slower                 |
| PHP handling | Via FastCGI                | Native module          |
| Best use     | Reverse proxy, API gateway | Dynamic apps           |

ğŸ‘‰ **Thatâ€™s why** Apache + PHP + high traffic = pain
ğŸ‘‰ **Nginx shines** as reverse proxy + load balancer

---

## 6ï¸âƒ£ Practical Example: Serving Static Files

### Nginx

```nginx
server {
    listen 80;
    root /var/www/html;

    location / {
        try_files $uri $uri/ =404;
    }
}
```

âœ” Single worker handles thousands of users downloading files
âœ” Zero blocking

---

### Apache (conceptually)

* Each file download occupies:

  * A process/thread
* 10k downloads = ğŸ’¥ RAM explosion

---

## 7ï¸âƒ£ Practical Example: Nginx as Reverse Proxy

```nginx
upstream backend {
    server 127.0.0.1:3000;
    server 127.0.0.1:3001;
}

server {
    listen 80;

    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### What happens internally:

* Nginx:

  * Handles 50k connections
* Backend (Node / Django / Laravel):

  * Handles only **actual processing**
* Backend stays fast and stable

---

## 8ï¸âƒ£ Why Nginx Wins in Microservices & Docker

* One Nginx container:

  * Routes traffic to many services
* Zero thread overhead
* Hot reload:

```bash
nginx -s reload
```

ğŸ‘‰ No downtime
ğŸ‘‰ No dropped connections

---

## 9ï¸âƒ£ Mental Model (Easy to Remember)

### Apache:

> â€œOne worker per customerâ€

### Nginx:

> â€œOne worker managing all customers efficientlyâ€

---

## ğŸ”Ÿ When to Use What?

âœ” Use **Nginx** when:

* High traffic
* Reverse proxy
* Load balancing
* Docker / microservices
* API gateway

âœ” Use **Apache** when:

* Simple PHP hosting
* `.htaccess` dependency
* Low traffic legacy apps

