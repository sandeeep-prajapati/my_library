Sure! Here’s a **multithreaded Python port scanner** that scans multiple ports concurrently for much faster results:

```python
import socket
import threading
from queue import Queue

# Thread-safe queue for ports
port_queue = Queue()
open_ports = []
lock = threading.Lock()

def scan_port(host):
    while not port_queue.empty():
        port = port_queue.get()
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(0.5)
            result = s.connect_ex((host, port))
            if result == 0:
                with lock:
                    print(f"[OPEN] Port {port}")
                    open_ports.append(port)
            s.close()
        except socket.error:
            pass
        finally:
            port_queue.task_done()

def main():
    host = input("Enter target host (IP or domain): ")
    start_port = int(input("Enter start port: "))
    end_port = int(input("Enter end port: "))
    num_threads = int(input("Enter number of threads: "))

    # Fill the queue with ports
    for port in range(start_port, end_port + 1):
        port_queue.put(port)

    print(f"Scanning ports {start_port}-{end_port} on {host} using {num_threads} threads...\n")

    # Start threads
    threads = []
    for _ in range(num_threads):
        t = threading.Thread(target=scan_port, args=(host,))
        t.start()
        threads.append(t)

    # Wait for all threads to finish
    port_queue.join()

    print("\nScan completed.")
    if open_ports:
        print(f"Open ports on {host}: {sorted(open_ports)}")
    else:
        print(f"No open ports found on {host} in the range {start_port}-{end_port}.")

if __name__ == "__main__":
    main()
```

---

### **Features:**

* Uses **`threading`** and **`Queue`** for concurrency.
* User-defined number of threads (faster with more threads, but don’t overload the network/target).
* Prints open ports in real-time and final sorted list.
* Handles socket exceptions safely.

---

I can also make a **version that supports scanning multiple hosts in parallel** using the same multithreaded approach, if you want to do network-wide scans.

