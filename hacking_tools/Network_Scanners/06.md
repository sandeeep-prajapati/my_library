Sure! Using **Scapy**, you can implement a **TCP SYN port scanner** that sends a SYN packet to a target port and analyzes the response (SYN-ACK means open, RST means closed). Here's a Python example:

```python
from scapy.all import IP, TCP, sr1, conf

def syn_scan(target_ip, port):
    """
    Perform a TCP SYN scan on the specified target IP and port.
    """
    conf.verb = 0  # Disable verbose output

    # Craft IP + TCP SYN packet
    syn_packet = IP(dst=target_ip)/TCP(dport=port, flags="S")
    
    # Send the packet and wait for a response
    response = sr1(syn_packet, timeout=2)

    if response is None:
        print(f"Port {port}: Filtered/No Response")
    elif response.haslayer(TCP):
        if response[TCP].flags == 0x12:  # SYN-ACK
            print(f"Port {port}: OPEN")
            # Send RST to gracefully close the connection
            rst_packet = IP(dst=target_ip)/TCP(dport=port, flags="R")
            sr1(rst_packet, timeout=1, verbose=0)
        elif response[TCP].flags == 0x14:  # RST-ACK
            print(f"Port {port}: CLOSED")
    else:
        print(f"Port {port}: Unexpected response")

if __name__ == "__main__":
    target = input("Enter target IP: ")
    port = int(input("Enter port to scan: "))
    syn_scan(target, port)
```

---

### **How it works**

1. **Crafts a TCP SYN packet** using Scapy.
2. Sends it to the target port and waits for a reply.
3. **Analyzes the flags in the TCP layer**:

   * `SYN-ACK (0x12)` â†’ Port is **OPEN**.
   * `RST-ACK (0x14)` â†’ Port is **CLOSED**.
   * No response â†’ Port is **filtered or blocked**.
4. Sends a **RST packet** to terminate the half-open connection gracefully (avoids completing a full TCP handshake).

---

ðŸ’¡ **Tip:**
You can extend this to **scan a range of ports** using a loop and multithreading, similar to our earlier socket-based scanner.

I can create a **full multithreaded SYN scanner using Scapy** for ranges of ports if you wantâ€”it will be much faster and stealthier than the basic socket scanner.

