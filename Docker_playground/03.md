## ğŸ“„ `docker-compose.yml` (With Custom Bridge Network)

version: "3.9"

services:
nginx:
image: nginx:latest
container_name: nginx_basic
ports:
- "8080:80"
volumes:
- ./html:/usr/share/nginx/html
networks:
- web_net

networks:
web_net:
driver: bridge

---

## ğŸ” Line-by-line Explanation (Only the New Parts)

### `networks:` (under service)

```yaml
networks:
  - web_net
```

* This tells Docker:
  **â€œAttach this container to a specific networkâ€**
* A service can be attached to:

  * One network
  * Multiple networks (very common in microservices)

---

### `networks:` (root level)

```yaml
networks:
  web_net:
    driver: bridge
```

* Defines a **custom Docker network**
* `web_net` is the network name
* `bridge` means:

  * Containers can talk to each other
  * Network is isolated from other Docker networks
  * Host access only via exposed ports

ğŸ‘‰ This is **not** the default network Docker creates automatically.
This is your own isolated playground.

---

## ğŸ§  Why Custom Networks Matter (Big Concept)

With a custom bridge network:

* Containers get **automatic DNS**
* Services can talk using **service names**
* You donâ€™t need IP addresses âŒ

Example (future state):

```bash
curl http://nginx
```

Docker resolves `nginx` â†’ container IP automatically.

---

## ğŸ§ª Verify the Network

Run:

```bash
docker network ls
```

Youâ€™ll see something like:

```
projectroot_web_net
```

Inspect it:

```bash
docker network inspect projectroot_web_net
```

Youâ€™ll see your Nginx container attached.

---

## ğŸ”¥ Real-World Analogy

Think of:

* **Network** â†’ Private office LAN
* **Container name** â†’ Computer hostname
* **Service name** â†’ DNS record

This is how:

* Django talks to PostgreSQL
* React talks to APIs
* Microservices discover each other

---
