## ğŸ“ Project Structure

```
fullstack-app/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ nginx/
â”‚   â””â”€â”€ nginx.conf
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ manage.py
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ backend/
â”‚       â””â”€â”€ settings.py
â””â”€â”€ frontend/
    â”œâ”€â”€ Dockerfile
    â”œâ”€â”€ package.json
    â””â”€â”€ src/
```

---

## ğŸ“„ `docker-compose.yml`

version: "3.9"

services:
backend:
build: ./backend
container_name: django_backend
command: >
sh -c "
python manage.py migrate &&
python manage.py runserver 0.0.0.0:8000
"
volumes:
- ./backend:/app
expose:
- "8000"
networks:
- app_net

frontend:
build: ./frontend
container_name: react_frontend
volumes:
- ./frontend:/app
- node_modules:/app/node_modules
expose:
- "3000"
environment:
- CHOKIDAR_USEPOLLING=true
networks:
- app_net

nginx:
image: nginx:alpine
container_name: nginx_proxy
ports:
- "80:80"
volumes:
- ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
depends_on:
- backend
- frontend
networks:
- app_net

networks:
app_net:
driver: bridge

volumes:
node_modules:

---

## ğŸ“„ `nginx/nginx.conf`

events {}

http {
upstream django {
server backend:8000;
}

upstream react {
server frontend:3000;
}

server {
listen 80;

```
location /api/ {
  proxy_pass http://django;
  proxy_set_header Host $host;
  proxy_set_header X-Real-IP $remote_addr;
}

location / {
  proxy_pass http://react;
  proxy_set_header Host $host;
  proxy_set_header X-Real-IP $remote_addr;
}
```

}
}

---

## ğŸ“„ Backend `Dockerfile` (Django)

FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

---

## ğŸ“„ Frontend `Dockerfile` (React â€“ Dev)

FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
EXPOSE 3000
CMD ["npm", "start"]

---

## ğŸ” How Traffic Flows (Very Important)

```
Browser
  â†“
Nginx (port 80)
  â”œâ”€â”€ /api/*  â†’ Django (backend:8000)
  â””â”€â”€ /       â†’ React (frontend:3000)
```

Why this is powerful:

* One public entry point
* Backend is never exposed directly
* Frontend and backend talk via Docker DNS
* Same setup works in staging & prod

---

## ğŸ§  Key Docker Concepts You Just Used

### âœ… Single Shared Network

```yaml
networks:
  - app_net
```

* All services can talk using service names
* `backend`, `frontend`, `nginx` = DNS hosts

---

### âœ… `expose` vs `ports`

* `expose` â†’ internal Docker access only
* `ports` â†’ public access (only Nginx)

Security win ğŸ”

---

### âœ… Reverse Proxy Pattern

* Nginx handles:

  * Routing
  * SSL (later)
  * Load balancing (later)
* App containers stay simple

---

## â–¶ï¸ Run the Full Stack

```bash
docker compose up --build
```

Open:

```
http://localhost
```

* React app loads ğŸ‰
* API requests `/api/...` hit Django ğŸ

